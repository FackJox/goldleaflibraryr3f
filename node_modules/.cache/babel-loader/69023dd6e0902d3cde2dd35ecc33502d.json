{"ast":null,"code":"export function observeElementRect(n, o) {\n  var i = e.get(n);\n  return void 0 === i ? (e.set(n, {\n    rect: {},\n    callbacks: [o]\n  }), 1 === e.size && (t = requestAnimationFrame(c))) : (i.callbacks.push(o), o(n.getBoundingClientRect())), function () {\n    var c = e.get(n);\n    if (void 0 === c) return;\n    var i = c.callbacks.indexOf(o);\n    i > -1 && c.callbacks.splice(i, 1), 0 === c.callbacks.length && (e.delete(n), 0 === e.size && cancelAnimationFrame(t));\n  };\n}\nvar t;\nvar e = new Map();\nfunction c() {\n  var n = [];\n  e.forEach(function (t, e) {\n    var c = e.getBoundingClientRect();\n    var o, i;\n    o = t.rect, i = c, (o.width !== i.width || o.height !== i.height || o.top !== i.top || o.right !== i.right || o.bottom !== i.bottom || o.left !== i.left) && (t.rect = c, n.push(t));\n  }), n.forEach(function (t) {\n    t.callbacks.forEach(function (e) {\n      return e(t.rect);\n    });\n  }), t = requestAnimationFrame(c);\n}","map":{"version":3,"sources":["packages/core/rect/src/observeElementRect.ts"],"names":["observeElementRect","elementToObserve","callback","observedData","observedElements","get","undefined","set","rect","callbacks","size","rafId","requestAnimationFrame","runLoop","push","getBoundingClientRect","index","indexOf","splice","length","delete","cancelAnimationFrame","Map","changedRectsData","forEach","data","element","newRect","rect1","rect2","width","height","top","right","bottom","left"],"mappings":"OAOA,SAASA,kBAAAA,CAEPC,CAAAA,EAEAC,CAAAA,EAAAA;EAEA,IAAMC,CAAAA,GAAeC,CAAAA,CAAiBC,GAAAA,CAAIJ,CAAAA,CAAAA;EAiB1C,OAAA,KAfqBK,CAAAA,KAAjBH,CAAAA,IAGFC,CAAAA,CAAiBG,GAAAA,CAAIN,CAAAA,EAAkB;IAAEO,IAAAA,EAAM,CAAA,CAAA;IAAkBC,SAAAA,EAAW,CAACP,CAAAA;EAAAA,CAAAA,CAAAA,EAE/C,CAAA,KAA1BE,CAAAA,CAAiBM,IAAAA,KAEnBC,CAAAA,GAAQC,qBAAAA,CAAsBC,CAAAA,CAAAA,CAAAA,KAIhCV,CAAAA,CAAaM,SAAAA,CAAUK,IAAAA,CAAKZ,CAAAA,CAAAA,EAC5BA,CAAAA,CAASD,CAAAA,CAAiBc,qBAAAA,EAAAA,CAAAA,CAAAA,EAGrB,YAAA;IACL,IAAMZ,CAAAA,GAAeC,CAAAA,CAAiBC,GAAAA,CAAIJ,CAAAA,CAAAA;IAC1C,IAAA,KAAqBK,CAAAA,KAAjBH,CAAAA,EAA4B;IAGhC,IAAMa,CAAAA,GAAQb,CAAAA,CAAaM,SAAAA,CAAUQ,OAAAA,CAAQf,CAAAA,CAAAA;IACzCc,CAAAA,GAAAA,CAAS,CAAA,IACXb,CAAAA,CAAaM,SAAAA,CAAUS,MAAAA,CAAOF,CAAAA,EAAO,CAAA,CAAA,EAGD,CAAA,KAAlCb,CAAAA,CAAaM,SAAAA,CAAUU,MAAAA,KAGzBf,CAAAA,CAAiBgB,MAAAA,CAAOnB,CAAAA,CAAAA,EAEM,CAAA,KAA1BG,CAAAA,CAAiBM,IAAAA,IAEnBW,oBAAAA,CAAqBV,CAAAA,CAAAA,CAAAA;EAAAA,CAAAA;AAAAA;AAgB7B,IAAIA,CAAAA;AACJ,IAAMP,CAAAA,GAAkD,IAAIkB,GAAAA;AAE5D,SAAST,CAAAA,GAAAA;EACP,IAAMU,CAAAA,GAAwC,EAAA;EAG9CnB,CAAAA,CAAiBoB,OAAAA,CAAQ,UAACC,CAAAA,EAAMC,CAAAA,EAAAA;IAC9B,IAAMC,CAAAA,GAAUD,CAAAA,CAAQX,qBAAAA,EAAAA;IAsB5B,IAAoBa,CAAAA,EAAmBC,CAAAA;IAAnBD,CAAAA,GAnBAH,CAAAA,CAAKjB,IAAAA,EAmBcqB,CAAAA,GAnBRF,CAAAA,EAAAA,CAqB3BC,CAAAA,CAAME,KAAAA,KAAUD,CAAAA,CAAMC,KAAAA,IACtBF,CAAAA,CAAMG,MAAAA,KAAWF,CAAAA,CAAME,MAAAA,IACvBH,CAAAA,CAAMI,GAAAA,KAAQH,CAAAA,CAAMG,GAAAA,IACpBJ,CAAAA,CAAMK,KAAAA,KAAUJ,CAAAA,CAAMI,KAAAA,IACtBL,CAAAA,CAAMM,MAAAA,KAAWL,CAAAA,CAAMK,MAAAA,IACvBN,CAAAA,CAAMO,IAAAA,KAASN,CAAAA,CAAMM,IAAAA,MAzBnBV,CAAAA,CAAKjB,IAAAA,GAAOmB,CAAAA,EACZJ,CAAAA,CAAiBT,IAAAA,CAAKW,CAAAA,CAAAA,CAAAA;EAAAA,CAAAA,CAAAA,EAM1BF,CAAAA,CAAiBC,OAAAA,CAASC,UAAAA,CAAAA,EAAAA;IACxBA,CAAAA,CAAKhB,SAAAA,CAAUe,OAAAA,CAAStB,UAAAA,CAAAA;MAAAA,OAAaA,CAAAA,CAASuB,CAAAA,CAAKjB,IAAAA,CAAAA;IAAAA,EAAAA;EAAAA,CAAAA,CAAAA,EAGrDG,CAAAA,GAAQC,qBAAAA,CAAsBC,CAAAA,CAAAA;AAAAA","sourcesContent":["type Measurable = { getBoundingClientRect(): ClientRect };\n\n/**\n * Observes an element's rectangle on screen (getBoundingClientRect)\n * This is useful to track elements on the screen and attach other elements\n * that might be in different layers, etc.\n */\nfunction observeElementRect(\n  /** The element whose rect to observe */\n  elementToObserve: Measurable,\n  /** The callback which will be called when the rect changes */\n  callback: CallbackFn\n) {\n  const observedData = observedElements.get(elementToObserve);\n\n  if (observedData === undefined) {\n    // add the element to the map of observed elements with its first callback\n    // because this is the first time this element is observed\n    observedElements.set(elementToObserve, { rect: {} as ClientRect, callbacks: [callback] });\n\n    if (observedElements.size === 1) {\n      // start the internal loop once at least 1 element is observed\n      rafId = requestAnimationFrame(runLoop);\n    }\n  } else {\n    // only add a callback for this element as it's already observed\n    observedData.callbacks.push(callback);\n    callback(elementToObserve.getBoundingClientRect());\n  }\n\n  return () => {\n    const observedData = observedElements.get(elementToObserve);\n    if (observedData === undefined) return;\n\n    // start by removing the callback\n    const index = observedData.callbacks.indexOf(callback);\n    if (index > -1) {\n      observedData.callbacks.splice(index, 1);\n    }\n\n    if (observedData.callbacks.length === 0) {\n      // stop observing this element because there are no\n      // callbacks registered for it anymore\n      observedElements.delete(elementToObserve);\n\n      if (observedElements.size === 0) {\n        // stop the internal loop once no elements are observed anymore\n        cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\n// ========================================================================\n// module internals\n\ntype CallbackFn = (rect: ClientRect) => void;\n\ntype ObservedData = {\n  rect: ClientRect;\n  callbacks: Array<CallbackFn>;\n};\n\nlet rafId: number;\nconst observedElements: Map<Measurable, ObservedData> = new Map();\n\nfunction runLoop() {\n  const changedRectsData: Array<ObservedData> = [];\n\n  // process all DOM reads first (getBoundingClientRect)\n  observedElements.forEach((data, element) => {\n    const newRect = element.getBoundingClientRect();\n\n    // gather all the data for elements whose rects have changed\n    if (!rectEquals(data.rect, newRect)) {\n      data.rect = newRect;\n      changedRectsData.push(data);\n    }\n  });\n\n  // group DOM writes here after the DOM reads (getBoundingClientRect)\n  // as DOM writes will most likely happen with the callbacks\n  changedRectsData.forEach((data) => {\n    data.callbacks.forEach((callback) => callback(data.rect));\n  });\n\n  rafId = requestAnimationFrame(runLoop);\n}\n// ========================================================================\n\n/**\n * Returns whether 2 rects are equal in values\n */\nfunction rectEquals(rect1: ClientRect, rect2: ClientRect) {\n  return (\n    rect1.width === rect2.width &&\n    rect1.height === rect2.height &&\n    rect1.top === rect2.top &&\n    rect1.right === rect2.right &&\n    rect1.bottom === rect2.bottom &&\n    rect1.left === rect2.left\n  );\n}\n\nexport { observeElementRect };\nexport type { Measurable };\n"]},"metadata":{},"sourceType":"module"}