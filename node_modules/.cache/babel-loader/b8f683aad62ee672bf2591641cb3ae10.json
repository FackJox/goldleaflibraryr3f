{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.firstForTerminal = exports.firstForBranching = exports.firstForSequence = exports.first = void 0;\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar uniq_1 = __importDefault(require(\"lodash/uniq\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar gast_1 = require(\"@chevrotain/gast\");\nvar gast_2 = require(\"@chevrotain/gast\");\nfunction first(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof gast_1.NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first(prod.referencedRule);\n  } else if (prod instanceof gast_1.Terminal) {\n    return firstForTerminal(prod);\n  } else if ((0, gast_2.isSequenceProd)(prod)) {\n    return firstForSequence(prod);\n  } else if ((0, gast_2.isBranchingProd)(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexports.first = first;\nfunction firstForSequence(prod) {\n  var firstSet = [];\n  var seq = prod.definition;\n  var nextSubProdIdx = 0;\n  var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  var currSubProd;\n  // so we enter the loop at least once (if the definition is not empty\n  var isLastInnerProdOptional = true;\n  // scan a sequence until it's end or until we have found a NONE optional production in it\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = (0, gast_2.isOptionalProd)(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n  return (0, uniq_1.default)(firstSet);\n}\nexports.firstForSequence = firstForSequence;\nfunction firstForBranching(prod) {\n  var allAlternativesFirsts = (0, map_1.default)(prod.definition, function (innerProd) {\n    return first(innerProd);\n  });\n  return (0, uniq_1.default)((0, flatten_1.default)(allAlternativesFirsts));\n}\nexports.firstForBranching = firstForBranching;\nfunction firstForTerminal(terminal) {\n  return [terminal.terminalType];\n}\nexports.firstForTerminal = firstForTerminal;","map":{"version":3,"sources":["../../../../src/parse/grammar/first.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,IAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;AACA,IAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;AACA,IAAA,KAAA,GAAA,eAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAOA,SAAgB,KAAK,CAAC,IAAiB,EAAA;EACrC;EACA,IAAI,IAAI,YAAY,MAAA,CAAA,WAAW,EAAE;IAC/B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,OAAO,KAAK,CAAe,IAAK,CAAC,cAAc,CAAC;GACjD,MAAM,IAAI,IAAI,YAAY,MAAA,CAAA,QAAQ,EAAE;IACnC,OAAO,gBAAgB,CAAW,IAAI,CAAC;GACxC,MAAM,IAAI,CAAA,CAAA,EAAA,MAAA,CAAA,cAAc,EAAC,IAAI,CAAC,EAAE;IAC/B,OAAO,gBAAgB,CAAC,IAAI,CAAC;GAC9B,MAAM,IAAI,CAAA,CAAA,EAAA,MAAA,CAAA,eAAe,EAAC,IAAI,CAAC,EAAE;IAChC,OAAO,iBAAiB,CAAC,IAAI,CAAC;GAC/B,MAAM;IACL,MAAM,KAAK,CAAC,sBAAsB,CAAC;EACpC;AACH;AArBA,OAAA,CAAA,KAAA,GAAA,KAAA;AAuBA,SAAgB,gBAAgB,CAAC,IAEhC,EAAA;EACC,IAAI,QAAQ,GAAgB,EAAE;EAC9B,IAAM,GAAG,GAAG,IAAI,CAAC,UAAU;EAC3B,IAAI,cAAc,GAAG,CAAC;EACtB,IAAI,sBAAsB,GAAG,GAAG,CAAC,MAAM,GAAG,cAAc;EACxD,IAAI,WAAW;EACf;EACA,IAAI,uBAAuB,GAAG,IAAI;EAClC;EACA,OAAO,sBAAsB,IAAI,uBAAuB,EAAE;IACxD,WAAW,GAAG,GAAG,CAAC,cAAc,CAAC;IACjC,uBAAuB,GAAG,CAAA,CAAA,EAAA,MAAA,CAAA,cAAc,EAAC,WAAW,CAAC;IACrD,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;IAC9C,cAAc,GAAG,cAAc,GAAG,CAAC;IACnC,sBAAsB,GAAG,GAAG,CAAC,MAAM,GAAG,cAAc;EACrD;EAED,OAAO,CAAA,CAAA,EAAA,MAAA,CAAA,OAAI,EAAC,QAAQ,CAAC;AACvB;AApBA,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAsBA,SAAgB,iBAAiB,CAAC,IAEjC,EAAA;EACC,IAAM,qBAAqB,GAAkB,CAAA,CAAA,EAAA,KAAA,CAAA,OAAG,EAC9C,IAAI,CAAC,UAAU,EACf,UAAC,SAAS,EAAA;IACR,OAAO,KAAK,CAAC,SAAS,CAAC;EACzB,CAAC,CACF;EACD,OAAO,CAAA,CAAA,EAAA,MAAA,CAAA,OAAI,EAAC,CAAA,CAAA,EAAA,SAAA,CAAA,OAAO,EAAY,qBAAqB,CAAC,CAAC;AACxD;AAVA,OAAA,CAAA,iBAAA,GAAA,iBAAA;AAYA,SAAgB,gBAAgB,CAAC,QAAkB,EAAA;EACjD,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAC;AAChC;AAFA,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.firstForTerminal = exports.firstForBranching = exports.firstForSequence = exports.first = void 0;\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar uniq_1 = __importDefault(require(\"lodash/uniq\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar gast_1 = require(\"@chevrotain/gast\");\nvar gast_2 = require(\"@chevrotain/gast\");\nfunction first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof gast_1.NonTerminal) {\n        // this could in theory cause infinite loops if\n        // (1) prod A refs prod B.\n        // (2) prod B refs prod A\n        // (3) AB can match the empty set\n        // in other words a cycle where everything is optional so the first will keep\n        // looking ahead for the next optional part and will never exit\n        // currently there is no safeguard for this unique edge case because\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\n        return first(prod.referencedRule);\n    }\n    else if (prod instanceof gast_1.Terminal) {\n        return firstForTerminal(prod);\n    }\n    else if ((0, gast_2.isSequenceProd)(prod)) {\n        return firstForSequence(prod);\n    }\n    else if ((0, gast_2.isBranchingProd)(prod)) {\n        return firstForBranching(prod);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexports.first = first;\nfunction firstForSequence(prod) {\n    var firstSet = [];\n    var seq = prod.definition;\n    var nextSubProdIdx = 0;\n    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    var currSubProd;\n    // so we enter the loop at least once (if the definition is not empty\n    var isLastInnerProdOptional = true;\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = (0, gast_2.isOptionalProd)(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return (0, uniq_1.default)(firstSet);\n}\nexports.firstForSequence = firstForSequence;\nfunction firstForBranching(prod) {\n    var allAlternativesFirsts = (0, map_1.default)(prod.definition, function (innerProd) {\n        return first(innerProd);\n    });\n    return (0, uniq_1.default)((0, flatten_1.default)(allAlternativesFirsts));\n}\nexports.firstForBranching = firstForBranching;\nfunction firstForTerminal(terminal) {\n    return [terminal.terminalType];\n}\nexports.firstForTerminal = firstForTerminal;\n//# sourceMappingURL=first.js.map"]},"metadata":{},"sourceType":"script"}