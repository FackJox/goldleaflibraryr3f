{"ast":null,"code":"import _defineProperty from \"/run/media/private/jack/Media/Projects/GoldenLeaf/LibraryR3F/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/run/media/private/jack/Media/Projects/GoldenLeaf/LibraryR3F/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nexport var SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"];\nexport var ALIGN_OPTIONS = [\"start\", \"center\", \"end\"];\nexport function getPlacementData(_ref) {\n  var p = _ref.anchorRect,\n    c = _ref.popperSize,\n    f = _ref.arrowSize,\n    _ref$arrowOffset = _ref.arrowOffset,\n    l = _ref$arrowOffset === void 0 ? 0 : _ref$arrowOffset,\n    d = _ref.side,\n    _ref$sideOffset = _ref.sideOffset,\n    h = _ref$sideOffset === void 0 ? 0 : _ref$sideOffset,\n    x = _ref.align,\n    _ref$alignOffset = _ref.alignOffset,\n    g = _ref$alignOffset === void 0 ? 0 : _ref$alignOffset,\n    _ref$shouldAvoidColli = _ref.shouldAvoidCollisions,\n    u = _ref$shouldAvoidColli === void 0 ? !0 : _ref$shouldAvoidColli,\n    w = _ref.collisionBoundariesRect,\n    _ref$collisionToleran = _ref.collisionTolerance,\n    m = _ref$collisionToleran === void 0 ? 0 : _ref$collisionToleran;\n  if (!p || !c || !w) return {\n    popperStyles: o,\n    arrowStyles: n\n  };\n  var y = function (e, r) {\n      var o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var i = arguments.length > 4 ? arguments[4] : undefined;\n      var p = i ? i.height : 0,\n        a = t(r, e, \"x\"),\n        s = t(r, e, \"y\"),\n        c = s.before - o - p,\n        f = s.after + o + p,\n        l = a.before - o - p,\n        d = a.after + o + p;\n      return {\n        top: {\n          start: {\n            x: a.start + n,\n            y: c\n          },\n          center: {\n            x: a.center,\n            y: c\n          },\n          end: {\n            x: a.end - n,\n            y: c\n          }\n        },\n        right: {\n          start: {\n            x: d,\n            y: s.start + n\n          },\n          center: {\n            x: d,\n            y: s.center\n          },\n          end: {\n            x: d,\n            y: s.end - n\n          }\n        },\n        bottom: {\n          start: {\n            x: a.start + n,\n            y: f\n          },\n          center: {\n            x: a.center,\n            y: f\n          },\n          end: {\n            x: a.end - n,\n            y: f\n          }\n        },\n        left: {\n          start: {\n            x: l,\n            y: s.start + n\n          },\n          center: {\n            x: l,\n            y: s.center\n          },\n          end: {\n            x: l,\n            y: s.end - n\n          }\n        }\n      };\n    }(c, p, h, g, f),\n    b = y[d][x];\n  if (!1 === u) {\n    var _t = e(b);\n    var _o = n;\n    f && (_o = i({\n      popperSize: c,\n      arrowSize: f,\n      arrowOffset: l,\n      side: d,\n      align: x\n    }));\n    return {\n      popperStyles: _objectSpread(_objectSpread({}, _t), {}, {\n        \"--radix-popper-transform-origin\": r(c, d, x, l, f)\n      }),\n      arrowStyles: _o,\n      placedSide: d,\n      placedAlign: x\n    };\n  }\n  var S = DOMRect.fromRect(_objectSpread(_objectSpread({}, c), b)),\n    $ = (O = w, z = m, DOMRect.fromRect({\n      width: O.width - 2 * z,\n      height: O.height - 2 * z,\n      x: O.left + z,\n      y: O.top + z\n    }));\n  var O, z;\n  var R = s(S, $),\n    M = y[a(d)][x],\n    D = function (t, e, r) {\n      var o = a(t);\n      return e[t] && !r[o] ? o : t;\n    }(d, R, s(DOMRect.fromRect(_objectSpread(_objectSpread({}, c), M)), $)),\n    A = function (t, e, r, o, n) {\n      var i = \"top\" === r || \"bottom\" === r,\n        p = i ? \"left\" : \"top\",\n        a = i ? \"right\" : \"bottom\",\n        s = i ? \"width\" : \"height\",\n        c = e[s] > t[s];\n      if ((\"start\" === o || \"center\" === o) && (n[p] && c || n[a] && !c)) return \"end\";\n      if ((\"end\" === o || \"center\" === o) && (n[a] && c || n[p] && !c)) return \"start\";\n      return o;\n    }(c, p, d, x, R),\n    I = e(y[D][A]);\n  var C = n;\n  f && (C = i({\n    popperSize: c,\n    arrowSize: f,\n    arrowOffset: l,\n    side: D,\n    align: A\n  }));\n  return {\n    popperStyles: _objectSpread(_objectSpread({}, I), {}, {\n      \"--radix-popper-transform-origin\": r(c, D, A, l, f)\n    }),\n    arrowStyles: C,\n    placedSide: D,\n    placedAlign: A\n  };\n}\nfunction t(t, e, r) {\n  var o = t[\"x\" === r ? \"left\" : \"top\"],\n    n = \"x\" === r ? \"width\" : \"height\",\n    i = t[n],\n    p = e[n];\n  return {\n    before: o - p,\n    start: o,\n    center: o + (i - p) / 2,\n    end: o + i - p,\n    after: o + i\n  };\n}\nfunction e(t) {\n  return {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    minWidth: \"max-content\",\n    willChange: \"transform\",\n    transform: \"translate3d(\".concat(Math.round(t.x + window.scrollX), \"px, \").concat(Math.round(t.y + window.scrollY), \"px, 0)\")\n  };\n}\nfunction r(t, e, r, o, n) {\n  var i = \"top\" === e || \"bottom\" === e,\n    p = n ? n.width : 0,\n    a = n ? n.height : 0,\n    s = p / 2 + o;\n  var c = \"\",\n    f = \"\";\n  return i ? (c = {\n    start: \"\".concat(s, \"px\"),\n    center: \"center\",\n    end: t.width - s + \"px\"\n  }[r], f = \"top\" === e ? \"\".concat(t.height + a, \"px\") : -a + \"px\") : (c = \"left\" === e ? \"\".concat(t.width + a, \"px\") : -a + \"px\", f = {\n    start: \"\".concat(s, \"px\"),\n    center: \"center\",\n    end: t.height - s + \"px\"\n  }[r]), \"\".concat(c, \" \").concat(f);\n}\nvar o = {\n    position: \"fixed\",\n    top: 0,\n    left: 0,\n    opacity: 0,\n    transform: \"translate3d(0, -200%, 0)\"\n  },\n  n = {\n    position: \"absolute\",\n    opacity: 0\n  };\nfunction i(_ref2) {\n  var _f;\n  var t = _ref2.popperSize,\n    e = _ref2.arrowSize,\n    r = _ref2.arrowOffset,\n    o = _ref2.side,\n    n = _ref2.align;\n  var i = (t.width - e.width) / 2,\n    a = (t.height - e.width) / 2,\n    s = {\n      top: 0,\n      right: 90,\n      bottom: 180,\n      left: -90\n    }[o],\n    c = Math.max(e.width, e.height),\n    f = (_f = {\n      width: \"\".concat(c, \"px\"),\n      height: \"\".concat(c, \"px\"),\n      transform: \"rotate(\".concat(s, \"deg)\"),\n      willChange: \"transform\",\n      position: \"absolute\"\n    }, _defineProperty(_f, o, \"100%\"), _defineProperty(_f, \"direction\", p(o, n)), _f);\n  return \"top\" !== o && \"bottom\" !== o || (\"start\" === n && (f.left = \"\".concat(r, \"px\")), \"center\" === n && (f.left = \"\".concat(i, \"px\")), \"end\" === n && (f.right = \"\".concat(r, \"px\"))), \"left\" !== o && \"right\" !== o || (\"start\" === n && (f.top = \"\".concat(r, \"px\")), \"center\" === n && (f.top = \"\".concat(a, \"px\")), \"end\" === n && (f.bottom = \"\".concat(r, \"px\"))), f;\n}\nfunction p(t, e) {\n  return (\"top\" !== t && \"right\" !== t || \"end\" !== e) && (\"bottom\" !== t && \"left\" !== t || \"end\" === e) ? \"ltr\" : \"rtl\";\n}\nfunction a(t) {\n  return {\n    top: \"bottom\",\n    right: \"left\",\n    bottom: \"top\",\n    left: \"right\"\n  }[t];\n}\nfunction s(t, e) {\n  return {\n    top: t.top < e.top,\n    right: t.right > e.right,\n    bottom: t.bottom > e.bottom,\n    left: t.left < e.left\n  };\n}","map":{"version":3,"sources":["packages/core/popper/src/popper.ts"],"names":["SIDE_OPTIONS","ALIGN_OPTIONS","getPlacementData","anchorRect","popperSize","arrowSize","arrowOffset","side","sideOffset","align","alignOffset","shouldAvoidCollisions","collisionBoundariesRect","collisionTolerance","popperStyles","UNMEASURED_POPPER_STYLES","arrowStyles","UNMEASURED_ARROW_STYLES","allPlacementPoints","getAllPlacementPoints","popperPoint","getPlacementStylesForPoint","getPopperArrowStyles","getTransformOrigin","placedSide","placedAlign","popperRect","DOMRect","fromRect","collisionBoundariesRectWithTolerance","popperCollisions","getCollisions","getOppositeSide","oppositeSidePopperPoint","getSideAccountingForCollisions","getAlignAccountingForCollisions","arrowBaseToTipLength","height","x","getPopperSlotsForAxis","y","topY","before","bottomY","after","leftX","rightX","top","start","center","end","right","bottom","left","axis","anchorStart","dimension","anchorDimension","popperDimension","collisions","oppositeSideCollisions","oppositeSide","anchorSize","isHorizontalSide","startBound","endBound","isAnchorBigger","point","Math","round","window","scrollX","scrollY","position","minWidth","willChange","transform","arrowBaseLength","width","opacity","popperCenterX","popperCenterY","rotation","arrowMaxDimension","max","styles","getArrowCssDirection","rect","amount"],"mappings":";;OAEA,IAAMA,YAAAA,GAAe,CAAC,KAAA,EAAO,OAAA,EAAS,QAAA,EAAU,MAAA,CAAA;AAAA,OAChD,IAAMC,aAAAA,GAAgB,CAAC,OAAA,EAAS,QAAA,EAAU,KAAA,CAAA;AAAA,OAmD1C,SAASC,gBAAAA,OAWc;EAAA,IAVrBC,CAAAA,QADwBA,UAAAA;IAExBC,CAAAA,QAFwBD,UAAAA;IAGxBE,CAAAA,QAHwBF,SAAAA;IAAAA,wBAAAA,WAAAA;IAIxBG,CAAAA,iCAAc,CAAA;IACdC,CAAAA,QALwBJ,IAAAA;IAAAA,uBAAAA,UAAAA;IAMxBK,CAAAA,gCAAa,CAAA;IACbC,CAAAA,QAPwBN,KAAAA;IAAAA,wBAAAA,WAAAA;IAQxBO,CAAAA,iCAAc,CAAA;IAAA,6BARUP,qBAAAA;IASxBQ,CAAAA,sCAAAA,CAAwB,CAAA;IACxBC,CAAAA,QAVwBT,uBAAAA;IAAAA,6BAAAA,kBAAAA;IAWxBU,CAAAA,sCAAqB,CAAA;EAIrB,IAAA,CAAKV,CAAAA,IAAAA,CAAeC,CAAAA,IAAAA,CAAeQ,CAAAA,EACjC,OAAO;IACLE,YAAAA,EAAcC,CAAAA;IACdC,WAAAA,EAAaC;EAAAA,CAAAA;EAKjB,IAAMC,CAAAA,GA+GR,UACEd,CAAAA,EACAD,CAAAA,EAGAE;MAAAA,IAFAG,CAAAA,uEAAqB,CAAA;MAAA,IACrBE,CAAAA,uEAAsB,CAAA;MAAA,IACtBL,CAAAA;MAEA,IAAM+B,CAAAA,GAAuB/B,CAAAA,GAAYA,CAAAA,CAAUgC,MAAAA,GAAS,CAAA;QAEtDC,CAAAA,GAAIC,CAAAA,CAAsBpC,CAAAA,EAAYC,CAAAA,EAAY,GAAA,CAAA;QAClDoC,CAAAA,GAAID,CAAAA,CAAsBpC,CAAAA,EAAYC,CAAAA,EAAY,GAAA,CAAA;QAElDqC,CAAAA,GAAUD,CAAAA,CAAEE,MAAAA,GAASlC,CAAAA,GAAa4B,CAAAA;QAClCO,CAAAA,GAAUH,CAAAA,CAAEI,KAAAA,GAASpC,CAAAA,GAAa4B,CAAAA;QAClCS,CAAAA,GAAUP,CAAAA,CAAEI,MAAAA,GAASlC,CAAAA,GAAa4B,CAAAA;QAClCU,CAAAA,GAAUR,CAAAA,CAAEM,KAAAA,GAASpC,CAAAA,GAAa4B,CAAAA;MA0BxC,OAvBgC;QAC9BW,GAAAA,EAAK;UACHC,KAAAA,EAAQ;YAAEV,CAAAA,EAAGA,CAAAA,CAAEU,KAAAA,GAAQtC,CAAAA;YAAa8B,CAAAA,EAAGC;UAAAA,CAAAA;UACvCQ,MAAAA,EAAQ;YAAEX,CAAAA,EAAGA,CAAAA,CAAEW,MAAAA;YAAqBT,CAAAA,EAAGC;UAAAA,CAAAA;UACvCS,GAAAA,EAAQ;YAAEZ,CAAAA,EAAGA,CAAAA,CAAEY,GAAAA,GAAMxC,CAAAA;YAAe8B,CAAAA,EAAGC;UAAAA;QAAAA,CAAAA;QAEzCU,KAAAA,EAAO;UACLH,KAAAA,EAAQ;YAAEV,CAAAA,EAAGQ,CAAAA;YAAQN,CAAAA,EAAGA,CAAAA,CAAEQ,KAAAA,GAAQtC;UAAAA,CAAAA;UAClCuC,MAAAA,EAAQ;YAAEX,CAAAA,EAAGQ,CAAAA;YAAQN,CAAAA,EAAGA,CAAAA,CAAES;UAAAA,CAAAA;UAC1BC,GAAAA,EAAQ;YAAEZ,CAAAA,EAAGQ,CAAAA;YAAQN,CAAAA,EAAGA,CAAAA,CAAEU,GAAAA,GAAMxC;UAAAA;QAAAA,CAAAA;QAElC0C,MAAAA,EAAQ;UACNJ,KAAAA,EAAQ;YAAEV,CAAAA,EAAGA,CAAAA,CAAEU,KAAAA,GAAQtC,CAAAA;YAAa8B,CAAAA,EAAGG;UAAAA,CAAAA;UACvCM,MAAAA,EAAQ;YAAEX,CAAAA,EAAGA,CAAAA,CAAEW,MAAAA;YAAqBT,CAAAA,EAAGG;UAAAA,CAAAA;UACvCO,GAAAA,EAAQ;YAAEZ,CAAAA,EAAGA,CAAAA,CAAEY,GAAAA,GAAMxC,CAAAA;YAAe8B,CAAAA,EAAGG;UAAAA;QAAAA,CAAAA;QAEzCU,IAAAA,EAAM;UACJL,KAAAA,EAAQ;YAAEV,CAAAA,EAAGO,CAAAA;YAAOL,CAAAA,EAAGA,CAAAA,CAAEQ,KAAAA,GAAQtC;UAAAA,CAAAA;UACjCuC,MAAAA,EAAQ;YAAEX,CAAAA,EAAGO,CAAAA;YAAOL,CAAAA,EAAGA,CAAAA,CAAES;UAAAA,CAAAA;UACzBC,GAAAA,EAAQ;YAAEZ,CAAAA,EAAGO,CAAAA;YAAOL,CAAAA,EAAGA,CAAAA,CAAEU,GAAAA,GAAMxC;UAAAA;QAAAA;MAAAA,CAAAA;IAAAA,CApJRS,CACzBf,CAAAA,EACAD,CAAAA,EACAK,CAAAA,EACAE,CAAAA,EACAL,CAAAA,CAAAA;IAIIe,CAAAA,GAAcF,CAAAA,CAAmBX,CAAAA,CAAAA,CAAME,CAAAA,CAAAA;EAG7C,IAAA,CAA8B,CAAA,KAA1BE,CAAAA,EAAiC;IACnC,IAAMG,EAAAA,GAAeO,CAAAA,CAA2BD,CAAAA,CAAAA;IAEhD,IAAIJ,EAAAA,GAAcC,CAAAA;IACdZ,CAAAA,KACFW,EAAAA,GAAcM,CAAAA,CAAqB;MAAElB,UAAAA,EAAAA,CAAAA;MAAYC,SAAAA,EAAAA,CAAAA;MAAWC,WAAAA,EAAAA,CAAAA;MAAaC,IAAAA,EAAAA,CAAAA;MAAME,KAAAA,EAAAA;IAAAA,CAAAA,CAAAA,CAAAA;IAKjF,OAAO;MACLK,YAAAA,kCACKA,EAAAA;QACH,iCAAA,EALoBS,CAAAA,CAAmBnB,CAAAA,EAAYG,CAAAA,EAAME,CAAAA,EAAOH,CAAAA,EAAaD,CAAAA;MAAAA,EAAAA;MAO/EW,WAAAA,EAAAA,EAAAA;MACAQ,UAAAA,EAAYjB,CAAAA;MACZkB,WAAAA,EAAahB;IAAAA,CAAAA;EAAAA;EAKjB,IAAMiB,CAAAA,GAAaC,OAAAA,CAAQC,QAAAA,iCAAcxB,CAAAA,GAAegB,CAAAA,EAAAA;IAGlDS,CAAAA,IAiXmB0D,CAAAA,GAhXvB3E,CAAAA,EAgXyC4E,CAAAA,GA/WzC3E,CAAAA,EAgXKc,OAAAA,CAAQC,QAAAA,CAAS;MACtBkD,KAAAA,EAAOS,CAAAA,CAAKT,KAAAA,GAAiB,CAAA,GAATU,CAAAA;MACpBnD,MAAAA,EAAQkD,CAAAA,CAAKlD,MAAAA,GAAkB,CAAA,GAATmD,CAAAA;MACtBlD,CAAAA,EAAGiD,CAAAA,CAAKlC,IAAAA,GAAOmC,CAAAA;MACfhD,CAAAA,EAAG+C,CAAAA,CAAKxC,GAAAA,GAAMyC;IAAAA,CAAAA,CAAAA,CAAAA;EALlB,IAA2BD,CAAAA,EAAkBC,CAAAA;EA3W3C,IAAM1D,CAAAA,GAAmBC,CAAAA,CAAcL,CAAAA,EAAYG,CAAAA,CAAAA;IAK7CI,CAAAA,GAA0Bf,CAAAA,CADXc,CAAAA,CAAgBzB,CAAAA,CAAAA,CAAAA,CAC4BE,CAAAA,CAAAA;IAW3De,CAAAA,GAqHR,UAEEjB,CAAAA,EAEAoD,CAAAA,EAEAC,CAAAA,EAAAA;MAEA,IAAMC,CAAAA,GAAe7B,CAAAA,CAAgBzB,CAAAA,CAAAA;MAGrC,OAAOoD,CAAAA,CAAWpD,CAAAA,CAAAA,IAAAA,CAAUqD,CAAAA,CAAuBC,CAAAA,CAAAA,GAAgBA,CAAAA,GAAetD,CAAAA;IAAAA,CAhI/D2B,CACjB3B,CAAAA,EACAuB,CAAAA,EARmCC,CAAAA,CAJEJ,OAAAA,CAAQC,QAAAA,iCAC1CxB,CAAAA,GACA6B,CAAAA,EAAAA,EAIHJ,CAAAA,CAAAA,CAAAA;IAWIJ,CAAAA,GA+HR,UAEErB,CAAAA,EAEA0D,CAAAA,EAEAvD,CAAAA,EAEAE,CAAAA,EAEAkD,CAAAA,EAAAA;MAEA,IAAMI,CAAAA,GAA4B,KAAA,KAATxD,CAAAA,IAA2B,QAAA,KAATA,CAAAA;QACrCyD,CAAAA,GAAaD,CAAAA,GAAmB,MAAA,GAAS,KAAA;QACzCE,CAAAA,GAAWF,CAAAA,GAAmB,OAAA,GAAU,QAAA;QACxCP,CAAAA,GAAYO,CAAAA,GAAmB,OAAA,GAAU,QAAA;QACzCG,CAAAA,GAAiBJ,CAAAA,CAAWN,CAAAA,CAAAA,GAAapD,CAAAA,CAAWoD,CAAAA,CAAAA;MAE1D,IAAA,CAAc,OAAA,KAAV/C,CAAAA,IAA+B,QAAA,KAAVA,CAAAA,MAClBkD,CAAAA,CAAWK,CAAAA,CAAAA,IAAeE,CAAAA,IAAoBP,CAAAA,CAAWM,CAAAA,CAAAA,IAAAA,CAAcC,CAAAA,CAAAA,EAC1E,OAAO,KAAA;MAIX,IAAA,CAAc,KAAA,KAAVzD,CAAAA,IAA6B,QAAA,KAAVA,CAAAA,MAChBkD,CAAAA,CAAWM,CAAAA,CAAAA,IAAaC,CAAAA,IAAoBP,CAAAA,CAAWK,CAAAA,CAAAA,IAAAA,CAAgBE,CAAAA,CAAAA,EAC1E,OAAO,OAAA;MAIX,OAAOzD,CAAAA;IAAAA,CA7Ja0B,CAClB/B,CAAAA,EACAD,CAAAA,EACAI,CAAAA,EACAE,CAAAA,EACAqB,CAAAA,CAAAA;IAMIhB,CAAAA,GAAeO,CAAAA,CAHKH,CAAAA,CAAmBM,CAAAA,CAAAA,CAAYC,CAAAA,CAAAA,CAAAA;EAKzD,IAAIT,CAAAA,GAAcC,CAAAA;EACdZ,CAAAA,KACFW,CAAAA,GAAcM,CAAAA,CAAqB;IACjClB,UAAAA,EAAAA,CAAAA;IACAC,SAAAA,EAAAA,CAAAA;IACAC,WAAAA,EAAAA,CAAAA;IACAC,IAAAA,EAAMiB,CAAAA;IACNf,KAAAA,EAAOgB;EAAAA,CAAAA,CAAAA,CAAAA;EAYX,OAAO;IACLX,YAAAA,kCACKA,CAAAA;MACH,iCAAA,EAXoBS,CAAAA,CACtBnB,CAAAA,EACAoB,CAAAA,EACAC,CAAAA,EACAnB,CAAAA,EACAD,CAAAA;IAAAA,EAAAA;IAQAW,WAAAA,EAAAA,CAAAA;IACAQ,UAAAA,EAAAA,CAAAA;IACAC,WAAAA,EAAAA;EAAAA,CAAAA;AAAAA;AAkDJ,SAASc,CAAAA,CAAsBpC,CAAAA,EAAwBC,CAAAA,EAAkBkD,CAAAA,EAAAA;EACvE,IACMC,CAAAA,GAAcpD,CAAAA,CADO,GAAA,KAATmD,CAAAA,GAAe,MAAA,GAAS,KAAA,CAAA;IAGpCE,CAAAA,GAAqB,GAAA,KAATF,CAAAA,GAAe,OAAA,GAAU,QAAA;IACrCG,CAAAA,GAAkBtD,CAAAA,CAAWqD,CAAAA,CAAAA;IAC7BE,CAAAA,GAAkBtD,CAAAA,CAAWoD,CAAAA,CAAAA;EAGnC,OAAO;IACLd,MAAAA,EAAQa,CAAAA,GAAcG,CAAAA;IACtBV,KAAAA,EAAQO,CAAAA;IACRN,MAAAA,EAAQM,CAAAA,GAAAA,CAAeE,CAAAA,GAAkBC,CAAAA,IAAmB,CAAA;IAC5DR,GAAAA,EAAQK,CAAAA,GAAcE,CAAAA,GAAkBC,CAAAA;IACxCd,KAAAA,EAAQW,CAAAA,GAAcE;EAAAA,CAAAA;AAAAA;AAyD1B,SAASpC,CAAAA,CAA2B8C,CAAAA,EAAAA;EAGlC,OAAO;IACLM,QAAAA,EAAU,UAAA;IACV1B,GAAAA,EAAK,CAAA;IACLM,IAAAA,EAAM,CAAA;IACNqB,QAAAA,EAAU,aAAA;IACVC,UAAAA,EAAY,WAAA;IACZC,SAAAA,wBARQR,IAAAA,CAAKC,KAAAA,CAAMF,CAAAA,CAAM7B,CAAAA,GAAIgC,MAAAA,CAAOC,OAAAA,CAAAA,iBAC5BH,IAAAA,CAAKC,KAAAA,CAAMF,CAAAA,CAAM3B,CAAAA,GAAI8B,MAAAA,CAAOE,OAAAA,CAAAA;EAAAA,CAAAA;AAAAA;AAWxC,SAASjD,CAAAA,CACPnB,CAAAA,EACAG,CAAAA,EACAE,CAAAA,EACAH,CAAAA,EACAD,CAAAA,EAAAA;EAEA,IAAM0D,CAAAA,GAA4B,KAAA,KAATxD,CAAAA,IAA2B,QAAA,KAATA,CAAAA;IAErCsE,CAAAA,GAAkBxE,CAAAA,GAAYA,CAAAA,CAAUyE,KAAAA,GAAQ,CAAA;IAEhDtE,CAAAA,GADuBH,CAAAA,GAAYA,CAAAA,CAAUgC,MAAAA,GAAS,CAAA;IAEtD3B,CAAAA,GAAcmE,CAAAA,GAAkB,CAAA,GAAIvE,CAAAA;EAE1C,IAAIgC,CAAAA,GAAI,EAAA;IACJE,CAAAA,GAAI,EAAA;EAoBR,OAlBIuB,CAAAA,IACFzB,CAAAA,GAAI;IACFU,KAAAA,YAAUtC,CAAAA,OAAAA;IACVuC,MAAAA,EAAQ,QAAA;IACRC,GAAAA,EAAQ9C,CAAAA,CAAW0E,KAAAA,GAAQpE,CAAAA,GAArB;EAAA,CAAA,CACND,CAAAA,CAAAA,EAEF+B,CAAAA,GAAa,KAAA,KAATjC,CAAAA,aAAoBH,CAAAA,CAAWiC,MAAAA,GAAS7B,CAAAA,UAAAA,CAAqBA,CAAAA,GAAH,IAAA,KAE9D8B,CAAAA,GAAa,MAAA,KAAT/B,CAAAA,aAAqBH,CAAAA,CAAW0E,KAAAA,GAAQtE,CAAAA,UAAAA,CAAqBA,CAAAA,GAAH,IAAA,EAE9DgC,CAAAA,GAAI;IACFQ,KAAAA,YAAUtC,CAAAA,OAAAA;IACVuC,MAAAA,EAAQ,QAAA;IACRC,GAAAA,EAAQ9C,CAAAA,CAAWiC,MAAAA,GAAS3B,CAAAA,GAAtB;EAAA,CAAA,CACND,CAAAA,CAAAA,CAAAA,YAGM6B,CAAAA,cAAKE,CAAAA,CAAAA;AAAAA;AAGjB,IAAMzB,CAAAA,GAA2C;IAG/C0D,QAAAA,EAAU,OAAA;IACV1B,GAAAA,EAAK,CAAA;IACLM,IAAAA,EAAM,CAAA;IACN0B,OAAAA,EAAS,CAAA;IACTH,SAAAA,EAAW;EAAA,CAAA;EAGP3D,CAAAA,GAA0C;IAG9CwD,QAAAA,EAAU,UAAA;IACVM,OAAAA,EAAS;EAAA,CAAA;AAoBX,SAASzD,CAAAA,QAKPb;EAAAA;EAAAA,IAJAL,CAAAA,SAD4BA,UAAAA;IAE5BC,CAAAA,SAF4BD,SAAAA;IAG5BE,CAAAA,SAH4BF,WAAAA;IAI5BG,CAAAA,SAJ4BH,IAAAA;IAK5BK,CAAAA,SAL4BL,KAAAA;EAO5B,IAAM4E,CAAAA,GAAAA,CAAiB5E,CAAAA,CAAW0E,KAAAA,GAAQzE,CAAAA,CAAUyE,KAAAA,IAAS,CAAA;IACvDG,CAAAA,GAAAA,CAAiB7E,CAAAA,CAAWiC,MAAAA,GAAShC,CAAAA,CAAUyE,KAAAA,IAAS,CAAA;IAGxDI,CAAAA,GADc;MAAEnC,GAAAA,EAAK,CAAA;MAAGI,KAAAA,EAAO,EAAA;MAAIC,MAAAA,EAAQ,GAAA;MAAKC,IAAAA,EAAAA,CAAO;IAAA,CAAA,CAChC9C,CAAAA,CAAAA;IACvB4E,CAAAA,GAAoBf,IAAAA,CAAKgB,GAAAA,CAAI/E,CAAAA,CAAUyE,KAAAA,EAAOzE,CAAAA,CAAUgC,MAAAA,CAAAA;IAExDgD,CAAAA;MAIJP,KAAAA,YAAUK,CAAAA,OAAAA;MACV9C,MAAAA,YAAW8C,CAAAA,OAAAA;MAGXP,SAAAA,mBAAqBM,CAAAA,SAAAA;MACrBP,UAAAA,EAAY,WAAA;MAGZF,QAAAA,EAAU;IAAA,uBACTlE,CAAAA,EAAO,MAAA,oCAMG+E,CAAAA,CAAqB/E,CAAAA,EAAME,CAAAA,CAAAA,MAAAA;EA2BxC,OAxBa,KAAA,KAATF,CAAAA,IAA2B,QAAA,KAATA,CAAAA,KACN,OAAA,KAAVE,CAAAA,KACF4E,CAAAA,CAAOhC,IAAAA,aAAU/C,CAAAA,OAAAA,CAAAA,EAEL,QAAA,KAAVG,CAAAA,KACF4E,CAAAA,CAAOhC,IAAAA,aAAU2B,CAAAA,OAAAA,CAAAA,EAEL,KAAA,KAAVvE,CAAAA,KACF4E,CAAAA,CAAOlC,KAAAA,aAAW7C,CAAAA,OAAAA,CAAAA,CAAAA,EAIT,MAAA,KAATC,CAAAA,IAA4B,OAAA,KAATA,CAAAA,KACP,OAAA,KAAVE,CAAAA,KACF4E,CAAAA,CAAOtC,GAAAA,aAASzC,CAAAA,OAAAA,CAAAA,EAEJ,QAAA,KAAVG,CAAAA,KACF4E,CAAAA,CAAOtC,GAAAA,aAASkC,CAAAA,OAAAA,CAAAA,EAEJ,KAAA,KAAVxE,CAAAA,KACF4E,CAAAA,CAAOjC,MAAAA,aAAY9C,CAAAA,OAAAA,CAAAA,CAAAA,EAIhB+E,CAAAA;AAAAA;AAMT,SAASC,CAAAA,CAAqB/E,CAAAA,EAAYE,CAAAA,EAAAA;EACxC,OAAA,CAAc,KAAA,KAATF,CAAAA,IAA2B,OAAA,KAATA,CAAAA,IAA+B,KAAA,KAAVE,CAAAA,MAI9B,QAAA,KAATF,CAAAA,IAA8B,MAAA,KAATA,CAAAA,IAA8B,KAAA,KAAVE,CAAAA,CAAAA,GAIvC,KAAA,GAPE,KAAA;AAAA;AAaX,SAASuB,CAAAA,CAAgBzB,CAAAA,EAAAA;EAOvB,OAN0C;IACxCwC,GAAAA,EAAK,QAAA;IACLI,KAAAA,EAAO,MAAA;IACPC,MAAAA,EAAQ,KAAA;IACRC,IAAAA,EAAM;EAAA,CAAA,CAEa9C,CAAAA,CAAAA;AAAAA;AAmBvB,SAASwB,CAAAA,CAEPwD,CAAAA,EAEA3E,CAAAA,EAAAA;EAEA,OAAO;IACLmC,GAAAA,EAAKwC,CAAAA,CAAKxC,GAAAA,GAAMnC,CAAAA,CAAwBmC,GAAAA;IACxCI,KAAAA,EAAOoC,CAAAA,CAAKpC,KAAAA,GAAQvC,CAAAA,CAAwBuC,KAAAA;IAC5CC,MAAAA,EAAQmC,CAAAA,CAAKnC,MAAAA,GAASxC,CAAAA,CAAwBwC,MAAAA;IAC9CC,IAAAA,EAAMkC,CAAAA,CAAKlC,IAAAA,GAAOzC,CAAAA,CAAwByC;EAAAA,CAAAA;AAAAA","sourcesContent":["import * as CSS from 'csstype';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Axis = 'x' | 'y';\ntype Side = typeof SIDE_OPTIONS[number];\ntype Align = typeof ALIGN_OPTIONS[number];\ntype Point = { x: number; y: number };\ntype Size = { width: number; height: number };\n\ntype GetPlacementDataOptions = {\n  /** The rect of the anchor we are placing around */\n  anchorRect?: ClientRect;\n  /** The size of the popper to place */\n  popperSize?: Size;\n  /** An optional arrow size */\n  arrowSize?: Size;\n  /** An optional arrow offset (along the side, default: 0) */\n  arrowOffset?: number;\n  /** The desired side */\n  side: Side;\n  /** An optional side offset (distance from the side, default: 0)  */\n  sideOffset?: number;\n  /** The desired alignment */\n  align: Align;\n  /** An optional alignment offset (distance along the side, default: 0) */\n  alignOffset?: number;\n  /** An option to turn on/off the collision handling (default: true) */\n  shouldAvoidCollisions?: boolean;\n  /** The rect which represents the boundaries for collision checks */\n  collisionBoundariesRect?: ClientRect;\n  /** The tolerance used for collisions, ie. if we want them to trigger a bit earlier (default: 0) */\n  collisionTolerance?: number;\n};\n\ntype PlacementData = {\n  popperStyles: CSS.Properties;\n  arrowStyles: CSS.Properties;\n  placedSide?: Side;\n  placedAlign?: Align;\n};\n\n/**\n * Given all the information necessary to compute it,\n * this function calculates all the necessary placement data.\n *\n * It will return:\n *\n * - the styles to apply to the popper (including a custom property that is useful to set the transform origin in the right place)\n * - the styles to apply to the arrow\n * - the placed side (because it might have changed because of collisions)\n * - the placed align (because it might have changed because of collisions)\n */\nfunction getPlacementData({\n  anchorRect,\n  popperSize,\n  arrowSize,\n  arrowOffset = 0,\n  side,\n  sideOffset = 0,\n  align,\n  alignOffset = 0,\n  shouldAvoidCollisions = true,\n  collisionBoundariesRect,\n  collisionTolerance = 0,\n}: GetPlacementDataOptions): PlacementData {\n  // if we're not ready to do all the measurements yet,\n  // we return some good default styles\n  if (!anchorRect || !popperSize || !collisionBoundariesRect) {\n    return {\n      popperStyles: UNMEASURED_POPPER_STYLES,\n      arrowStyles: UNMEASURED_ARROW_STYLES,\n    };\n  }\n\n  // pre-compute points for all potential placements\n  const allPlacementPoints = getAllPlacementPoints(\n    popperSize,\n    anchorRect,\n    sideOffset,\n    alignOffset,\n    arrowSize\n  );\n\n  // get point based on side / align\n  const popperPoint = allPlacementPoints[side][align];\n\n  // if we don't need to avoid collisions, we can stop here\n  if (shouldAvoidCollisions === false) {\n    const popperStyles = getPlacementStylesForPoint(popperPoint);\n\n    let arrowStyles = UNMEASURED_ARROW_STYLES;\n    if (arrowSize) {\n      arrowStyles = getPopperArrowStyles({ popperSize, arrowSize, arrowOffset, side, align });\n    }\n\n    const transformOrigin = getTransformOrigin(popperSize, side, align, arrowOffset, arrowSize);\n\n    return {\n      popperStyles: {\n        ...popperStyles,\n        ['--radix-popper-transform-origin' as any]: transformOrigin,\n      },\n      arrowStyles,\n      placedSide: side,\n      placedAlign: align,\n    };\n  }\n\n  // create a new rect as if element had been moved to new placement\n  const popperRect = DOMRect.fromRect({ ...popperSize, ...popperPoint });\n\n  // create a new rect representing the collision boundaries but taking into account any added tolerance\n  const collisionBoundariesRectWithTolerance = getContractedRect(\n    collisionBoundariesRect,\n    collisionTolerance\n  );\n\n  // check for any collisions in new placement\n  const popperCollisions = getCollisions(popperRect, collisionBoundariesRectWithTolerance);\n\n  // do all the same calculations for the opposite side\n  // this is because we need to check for potential collisions if we were to swap side\n  const oppositeSide = getOppositeSide(side);\n  const oppositeSidePopperPoint = allPlacementPoints[oppositeSide][align];\n  const updatedOppositeSidePopperPoint = DOMRect.fromRect({\n    ...popperSize,\n    ...oppositeSidePopperPoint,\n  });\n  const oppositeSidePopperCollisions = getCollisions(\n    updatedOppositeSidePopperPoint,\n    collisionBoundariesRectWithTolerance\n  );\n\n  // adjust side accounting for collisions / opposite side collisions\n  const placedSide = getSideAccountingForCollisions(\n    side,\n    popperCollisions,\n    oppositeSidePopperCollisions\n  );\n\n  // adjust alignnment accounting for collisions\n  const placedAlign = getAlignAccountingForCollisions(\n    popperSize,\n    anchorRect,\n    side,\n    align,\n    popperCollisions\n  );\n\n  const placedPopperPoint = allPlacementPoints[placedSide][placedAlign];\n\n  // compute adjusted popper / arrow styles\n  const popperStyles = getPlacementStylesForPoint(placedPopperPoint);\n\n  let arrowStyles = UNMEASURED_ARROW_STYLES;\n  if (arrowSize) {\n    arrowStyles = getPopperArrowStyles({\n      popperSize,\n      arrowSize,\n      arrowOffset,\n      side: placedSide,\n      align: placedAlign,\n    });\n  }\n\n  const transformOrigin = getTransformOrigin(\n    popperSize,\n    placedSide,\n    placedAlign,\n    arrowOffset,\n    arrowSize\n  );\n\n  return {\n    popperStyles: {\n      ...popperStyles,\n      ['--radix-popper-transform-origin' as any]: transformOrigin,\n    },\n    arrowStyles,\n    placedSide,\n    placedAlign,\n  };\n}\n\ntype AllPlacementPoints = Record<Side, Record<Align, Point>>;\n\nfunction getAllPlacementPoints(\n  popperSize: Size,\n  anchorRect: ClientRect,\n  sideOffset: number = 0,\n  alignOffset: number = 0,\n  arrowSize?: Size\n): AllPlacementPoints {\n  const arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;\n\n  const x = getPopperSlotsForAxis(anchorRect, popperSize, 'x');\n  const y = getPopperSlotsForAxis(anchorRect, popperSize, 'y');\n\n  const topY    = y.before - sideOffset - arrowBaseToTipLength; // prettier-ignore\n  const bottomY = y.after  + sideOffset + arrowBaseToTipLength; // prettier-ignore\n  const leftX   = x.before - sideOffset - arrowBaseToTipLength; // prettier-ignore\n  const rightX  = x.after  + sideOffset + arrowBaseToTipLength; // prettier-ignore\n\n  // prettier-ignore\n  const map: AllPlacementPoints = {\n    top: {\n      start:  { x: x.start + alignOffset, y: topY },\n      center: { x: x.center,              y: topY },\n      end:    { x: x.end - alignOffset,   y: topY },\n    },\n    right: {\n      start:  { x: rightX, y: y.start + alignOffset },\n      center: { x: rightX, y: y.center },\n      end:    { x: rightX, y: y.end - alignOffset },\n    },\n    bottom: {\n      start:  { x: x.start + alignOffset, y: bottomY },\n      center: { x: x.center,              y: bottomY },\n      end:    { x: x.end - alignOffset,   y: bottomY },\n    },\n    left: {\n      start:  { x: leftX, y: y.start + alignOffset },\n      center: { x: leftX, y: y.center },\n      end:    { x: leftX, y: y.end - alignOffset },\n    },\n  };\n\n  return map;\n}\n\nfunction getPopperSlotsForAxis(anchorRect: ClientRect, popperSize: Size, axis: Axis) {\n  const startSide = axis === 'x' ? 'left' : 'top';\n  const anchorStart = anchorRect[startSide];\n\n  const dimension = axis === 'x' ? 'width' : 'height';\n  const anchorDimension = anchorRect[dimension];\n  const popperDimension = popperSize[dimension];\n\n  // prettier-ignore\n  return {\n    before: anchorStart - popperDimension,\n    start:  anchorStart,\n    center: anchorStart + (anchorDimension - popperDimension) / 2,\n    end:    anchorStart + anchorDimension - popperDimension,\n    after:  anchorStart + anchorDimension,\n  };\n}\n\n/**\n * Gets an adjusted side based on collision information\n */\nfunction getSideAccountingForCollisions(\n  /** The side we want to ideally position to */\n  side: Side,\n  /** The collisions for this given side */\n  collisions: Collisions,\n  /** The collisions for the opposite side (if we were to swap side) */\n  oppositeSideCollisions: Collisions\n): Side {\n  const oppositeSide = getOppositeSide(side);\n  // in order to prevent premature jumps\n  // we only swap side if there's enough space to fit on the opposite side\n  return collisions[side] && !oppositeSideCollisions[oppositeSide] ? oppositeSide : side;\n}\n\n/**\n * Gets an adjusted alignment based on collision information\n */\nfunction getAlignAccountingForCollisions(\n  /** The size of the popper to place */\n  popperSize: Size,\n  /** The size of the anchor we are placing around */\n  anchorSize: Size,\n  /** The final side */\n  side: Side,\n  /** The desired align */\n  align: Align,\n  /** The collisions */\n  collisions: Collisions\n): Align {\n  const isHorizontalSide = side === 'top' || side === 'bottom';\n  const startBound = isHorizontalSide ? 'left' : 'top';\n  const endBound = isHorizontalSide ? 'right' : 'bottom';\n  const dimension = isHorizontalSide ? 'width' : 'height';\n  const isAnchorBigger = anchorSize[dimension] > popperSize[dimension];\n\n  if (align === 'start' || align === 'center') {\n    if ((collisions[startBound] && isAnchorBigger) || (collisions[endBound] && !isAnchorBigger)) {\n      return 'end';\n    }\n  }\n\n  if (align === 'end' || align === 'center') {\n    if ((collisions[endBound] && isAnchorBigger) || (collisions[startBound] && !isAnchorBigger)) {\n      return 'start';\n    }\n  }\n\n  return align;\n}\n\nfunction getPlacementStylesForPoint(point: Point): CSS.Properties {\n  const x = Math.round(point.x + window.scrollX);\n  const y = Math.round(point.y + window.scrollY);\n  return {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    minWidth: 'max-content',\n    willChange: 'transform',\n    transform: `translate3d(${x}px, ${y}px, 0)`,\n  };\n}\n\nfunction getTransformOrigin(\n  popperSize: Size,\n  side: Side,\n  align: Align,\n  arrowOffset: number,\n  arrowSize?: Size\n): CSS.Properties['transformOrigin'] {\n  const isHorizontalSide = side === 'top' || side === 'bottom';\n\n  const arrowBaseLength = arrowSize ? arrowSize.width : 0;\n  const arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;\n  const sideOffset = arrowBaseToTipLength;\n  const alignOffset = arrowBaseLength / 2 + arrowOffset;\n\n  let x = '';\n  let y = '';\n\n  if (isHorizontalSide) {\n    x = {\n      start: `${alignOffset}px`,\n      center: 'center',\n      end: `${popperSize.width - alignOffset}px`,\n    }[align];\n\n    y = side === 'top' ? `${popperSize.height + sideOffset}px` : `${-sideOffset}px`;\n  } else {\n    x = side === 'left' ? `${popperSize.width + sideOffset}px` : `${-sideOffset}px`;\n\n    y = {\n      start: `${alignOffset}px`,\n      center: 'center',\n      end: `${popperSize.height - alignOffset}px`,\n    }[align];\n  }\n\n  return `${x} ${y}`;\n}\n\nconst UNMEASURED_POPPER_STYLES: CSS.Properties = {\n  // position: 'fixed' here is important because it will take the popper\n  // out of the flow so it does not disturb the position of the anchor\n  position: 'fixed',\n  top: 0,\n  left: 0,\n  opacity: 0,\n  transform: 'translate3d(0, -200%, 0)',\n};\n\nconst UNMEASURED_ARROW_STYLES: CSS.Properties = {\n  // given the arrow is nested inside the popper,\n  // make sure that it is out of the flow and doesn't hinder then popper's measurement\n  position: 'absolute',\n  opacity: 0,\n};\n\ntype GetArrowStylesOptions = {\n  /** The size of the popper to place */\n  popperSize: Size;\n  /** The size of the arrow itself */\n  arrowSize: Size;\n  /** An offset for the arrow along the align axis */\n  arrowOffset: number;\n  /** The side where the arrow points to */\n  side: Side;\n  /** The alignment of the arrow along the side */\n  align: Align;\n};\n\n/**\n * Computes the styles necessary to position, rotate and align the arrow correctly.\n * It can adjust itself based on anchor/popper size, side/align and an optional offset.\n */\nfunction getPopperArrowStyles({\n  popperSize,\n  arrowSize,\n  arrowOffset,\n  side,\n  align,\n}: GetArrowStylesOptions): CSS.Properties {\n  const popperCenterX = (popperSize.width - arrowSize.width) / 2;\n  const popperCenterY = (popperSize.height - arrowSize.width) / 2;\n\n  const rotationMap = { top: 0, right: 90, bottom: 180, left: -90 };\n  const rotation = rotationMap[side];\n  const arrowMaxDimension = Math.max(arrowSize.width, arrowSize.height);\n\n  const styles: CSS.Properties = {\n    // we make sure we put the arrow inside a 1:1 ratio container\n    // this is to make the rotation handling simpler\n    // as we do no need to worry about changing the transform-origin\n    width: `${arrowMaxDimension}px`,\n    height: `${arrowMaxDimension}px`,\n\n    // rotate the arrow appropriately\n    transform: `rotate(${rotation}deg)`,\n    willChange: 'transform',\n\n    // position the arrow appropriately\n    position: 'absolute',\n    [side]: '100%',\n\n    // Because the arrow gets rotated (see `transform above`)\n    // and we are putting it inside a 1:1 ratio container\n    // we need to adjust the CSS direction from `ltr` to `rtl`\n    // in some circumstances\n    direction: getArrowCssDirection(side, align),\n  };\n\n  if (side === 'top' || side === 'bottom') {\n    if (align === 'start') {\n      styles.left = `${arrowOffset}px`;\n    }\n    if (align === 'center') {\n      styles.left = `${popperCenterX}px`;\n    }\n    if (align === 'end') {\n      styles.right = `${arrowOffset}px`;\n    }\n  }\n\n  if (side === 'left' || side === 'right') {\n    if (align === 'start') {\n      styles.top = `${arrowOffset}px`;\n    }\n    if (align === 'center') {\n      styles.top = `${popperCenterY}px`;\n    }\n    if (align === 'end') {\n      styles.bottom = `${arrowOffset}px`;\n    }\n  }\n\n  return styles;\n}\n\n/**\n * Adjusts the arrow's CSS direction (`ltr` / `rtl`)\n */\nfunction getArrowCssDirection(side: Side, align: Align): CSS.Property.Direction {\n  if ((side === 'top' || side === 'right') && align === 'end') {\n    return 'rtl';\n  }\n\n  if ((side === 'bottom' || side === 'left') && align !== 'end') {\n    return 'rtl';\n  }\n\n  return 'ltr';\n}\n\n/**\n * Gets the opposite side of a given side (ie. top => bottom, left => right, â€¦)\n */\nfunction getOppositeSide(side: Side): Side {\n  const oppositeSides: Record<Side, Side> = {\n    top: 'bottom',\n    right: 'left',\n    bottom: 'top',\n    left: 'right',\n  };\n  return oppositeSides[side];\n}\n\n/**\n * Creates a new rect (`ClientRect`) based on a given one but contracted by\n * a given amout on each side.\n */\nfunction getContractedRect(rect: ClientRect, amount: number) {\n  return DOMRect.fromRect({\n    width: rect.width - amount * 2,\n    height: rect.height - amount * 2,\n    x: rect.left + amount,\n    y: rect.top + amount,\n  });\n}\n\n/**\n * Gets collisions for each side of a rect (top, right, bottom, left)\n */\nfunction getCollisions(\n  /** The rect to test collisions against */\n  rect: ClientRect,\n  /** The rect which represents the boundaries for collision checks */\n  collisionBoundariesRect: ClientRect\n) {\n  return {\n    top: rect.top < collisionBoundariesRect.top,\n    right: rect.right > collisionBoundariesRect.right,\n    bottom: rect.bottom > collisionBoundariesRect.bottom,\n    left: rect.left < collisionBoundariesRect.left,\n  };\n}\n\ntype Collisions = ReturnType<typeof getCollisions>;\n\nexport { getPlacementData, SIDE_OPTIONS, ALIGN_OPTIONS };\nexport type { Side, Align };\n"]},"metadata":{},"sourceType":"module"}