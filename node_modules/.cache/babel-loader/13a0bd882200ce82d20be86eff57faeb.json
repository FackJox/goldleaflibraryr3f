{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;\nvar regexp_to_ast_1 = require(\"regexp-to-ast\");\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar every_1 = __importDefault(require(\"lodash/every\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar find_1 = __importDefault(require(\"lodash/find\"));\nvar values_1 = __importDefault(require(\"lodash/values\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar utils_1 = require(\"@chevrotain/utils\");\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\nvar lexer_1 = require(\"./lexer\");\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexports.failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n  if (ensureOptimizations === void 0) {\n    ensureOptimizations = false;\n  }\n  try {\n    var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);\n    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        (0, utils_1.PRINT_WARNING)(\"\".concat(exports.failedOptimizationPrefixMsg) + \"\\tUnable to optimize: < \".concat(regExp.toString(), \" >\\n\") + \"\\tComplement Sets cannot be automatically optimized.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n      }\n    } else {\n      var msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      (0, utils_1.PRINT_ERROR)(\"\".concat(exports.failedOptimizationPrefixMsg, \"\\n\") + \"\\tFailed parsing: < \".concat(regExp.toString(), \" >\\n\") + \"\\tUsing the regexp-to-ast library version: \".concat(regexp_to_ast_1.VERSION, \"\\n\") + \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" + msgSuffix);\n    }\n  }\n  return [];\n}\nexports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (var i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      var terms = ast.value;\n      for (var i = 0; i < terms.length; i++) {\n        var term = terms[i];\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n        var atom = term;\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            (0, forEach_1.default)(atom.value, function (code) {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                var range = code;\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= lexer_1.minOptimizationVal) {\n                    var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;\n                    var maxUnOptVal = range.to;\n                    var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);\n                    var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);\n                    for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n        if (\n        // A group may be optional due to empty contents /(?:)/\n        // or if everything inside it is optional /((a)?)/\n        atom.type === \"Group\" && isWholeOptional(atom) === false ||\n        // If this term is not a group it may only be optional if it has an optional quantifier\n        atom.type !== \"Group\" && isOptionalQuantifier === false) {\n          break;\n        }\n      }\n      break;\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n  // console.log(Object.keys(result).length)\n  return (0, values_1.default)(result);\n}\nexports.firstCharOptimizedIndices = firstCharOptimizedIndices;\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\nfunction handleIgnoreCase(code, result) {\n  var char = String.fromCharCode(code);\n  var upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    var lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\nfunction findCode(setNode, targetCharCodes) {\n  return (0, find_1.default)(setNode.value, function (codeOrRange) {\n    if (typeof codeOrRange === \"number\") {\n      return (0, includes_1.default)(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      var range_1 = codeOrRange;\n      return (0, find_1.default)(targetCharCodes, function (targetCode) {\n        return range_1.from <= targetCode && targetCode <= range_1.to;\n      }) !== undefined;\n    }\n  });\n}\nfunction isWholeOptional(ast) {\n  var quantifier = ast.quantifier;\n  if (quantifier && quantifier.atLeast === 0) {\n    return true;\n  }\n  if (!ast.value) {\n    return false;\n  }\n  return (0, isArray_1.default)(ast.value) ? (0, every_1.default)(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */function (_super) {\n  __extends(CharCodeFinder, _super);\n  function CharCodeFinder(targetCharCodes) {\n    var _this = _super.call(this) || this;\n    _this.targetCharCodes = targetCharCodes;\n    _this.found = false;\n    return _this;\n  }\n  CharCodeFinder.prototype.visitChildren = function (node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    }\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n    _super.prototype.visitChildren.call(this, node);\n  };\n  CharCodeFinder.prototype.visitCharacter = function (node) {\n    if ((0, includes_1.default)(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  };\n  CharCodeFinder.prototype.visitSet = function (node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  };\n  return CharCodeFinder;\n}(regexp_to_ast_1.BaseRegExpVisitor);\nfunction canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);\n    var charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return (0, find_1.default)(pattern, function (char) {\n      return (0, includes_1.default)(charCodes, char.charCodeAt(0));\n    }) !== undefined;\n  }\n}\nexports.canMatchCharCode = canMatchCharCode;","map":{"version":3,"sources":["../../../src/scan/reg_exp.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;\nvar regexp_to_ast_1 = require(\"regexp-to-ast\");\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar every_1 = __importDefault(require(\"lodash/every\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar find_1 = __importDefault(require(\"lodash/find\"));\nvar values_1 = __importDefault(require(\"lodash/values\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar utils_1 = require(\"@chevrotain/utils\");\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\nvar lexer_1 = require(\"./lexer\");\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexports.failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n    if (ensureOptimizations === void 0) { ensureOptimizations = false; }\n    try {\n        var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);\n        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n    }\n    catch (e) {\n        /* istanbul ignore next */\n        // Testing this relies on the regexp-to-ast library having a bug... */\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n        if (e.message === complementErrorMessage) {\n            if (ensureOptimizations) {\n                (0, utils_1.PRINT_WARNING)(\"\".concat(exports.failedOptimizationPrefixMsg) +\n                    \"\\tUnable to optimize: < \".concat(regExp.toString(), \" >\\n\") +\n                    \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n            }\n        }\n        else {\n            var msgSuffix = \"\";\n            if (ensureOptimizations) {\n                msgSuffix =\n                    \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n                        \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n            }\n            (0, utils_1.PRINT_ERROR)(\"\".concat(exports.failedOptimizationPrefixMsg, \"\\n\") +\n                \"\\tFailed parsing: < \".concat(regExp.toString(), \" >\\n\") +\n                \"\\tUsing the regexp-to-ast library version: \".concat(regexp_to_ast_1.VERSION, \"\\n\") +\n                \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n                msgSuffix);\n        }\n    }\n    return [];\n}\nexports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n        case \"Disjunction\":\n            for (var i = 0; i < ast.value.length; i++) {\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n            }\n            break;\n        case \"Alternative\":\n            var terms = ast.value;\n            for (var i = 0; i < terms.length; i++) {\n                var term = terms[i];\n                // skip terms that cannot effect the first char results\n                switch (term.type) {\n                    case \"EndAnchor\":\n                    // A group back reference cannot affect potential starting char.\n                    // because if a back reference is the first production than automatically\n                    // the group being referenced has had to come BEFORE so its codes have already been added\n                    case \"GroupBackReference\":\n                    // assertions do not affect potential starting codes\n                    case \"Lookahead\":\n                    case \"NegativeLookahead\":\n                    case \"StartAnchor\":\n                    case \"WordBoundary\":\n                    case \"NonWordBoundary\":\n                        continue;\n                }\n                var atom = term;\n                switch (atom.type) {\n                    case \"Character\":\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                        break;\n                    case \"Set\":\n                        if (atom.complement === true) {\n                            throw Error(complementErrorMessage);\n                        }\n                        (0, forEach_1.default)(atom.value, function (code) {\n                            if (typeof code === \"number\") {\n                                addOptimizedIdxToResult(code, result, ignoreCase);\n                            }\n                            else {\n                                // range\n                                var range = code;\n                                // cannot optimize when ignoreCase is\n                                if (ignoreCase === true) {\n                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                }\n                                // Optimization (2 orders of magnitude less work for very large ranges)\n                                else {\n                                    // handle unoptimized values\n                                    for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                                    if (range.to >= lexer_1.minOptimizationVal) {\n                                        var minUnOptVal = range.from >= lexer_1.minOptimizationVal\n                                            ? range.from\n                                            : lexer_1.minOptimizationVal;\n                                        var maxUnOptVal = range.to;\n                                        var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);\n                                        var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);\n                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                                            result[currOptIdx] = currOptIdx;\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case \"Group\":\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                        break;\n                    /* istanbul ignore next */\n                    default:\n                        throw Error(\"Non Exhaustive Match\");\n                }\n                // reached a mandatory production, no more **start** codes can be found on this alternative\n                var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n                if (\n                // A group may be optional due to empty contents /(?:)/\n                // or if everything inside it is optional /((a)?)/\n                (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n                    // If this term is not a group it may only be optional if it has an optional quantifier\n                    (atom.type !== \"Group\" && isOptionalQuantifier === false)) {\n                    break;\n                }\n            }\n            break;\n        /* istanbul ignore next */\n        default:\n            throw Error(\"non exhaustive match!\");\n    }\n    // console.log(Object.keys(result).length)\n    return (0, values_1.default)(result);\n}\nexports.firstCharOptimizedIndices = firstCharOptimizedIndices;\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n    var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);\n    result[optimizedCharIdx] = optimizedCharIdx;\n    if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n    }\n}\nfunction handleIgnoreCase(code, result) {\n    var char = String.fromCharCode(code);\n    var upperChar = char.toUpperCase();\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n        var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n    }\n    else {\n        var lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n            var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));\n            result[optimizedCharIdx] = optimizedCharIdx;\n        }\n    }\n}\nfunction findCode(setNode, targetCharCodes) {\n    return (0, find_1.default)(setNode.value, function (codeOrRange) {\n        if (typeof codeOrRange === \"number\") {\n            return (0, includes_1.default)(targetCharCodes, codeOrRange);\n        }\n        else {\n            // range\n            var range_1 = codeOrRange;\n            return ((0, find_1.default)(targetCharCodes, function (targetCode) { return range_1.from <= targetCode && targetCode <= range_1.to; }) !== undefined);\n        }\n    });\n}\nfunction isWholeOptional(ast) {\n    var quantifier = ast.quantifier;\n    if (quantifier && quantifier.atLeast === 0) {\n        return true;\n    }\n    if (!ast.value) {\n        return false;\n    }\n    return (0, isArray_1.default)(ast.value)\n        ? (0, every_1.default)(ast.value, isWholeOptional)\n        : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */ (function (_super) {\n    __extends(CharCodeFinder, _super);\n    function CharCodeFinder(targetCharCodes) {\n        var _this = _super.call(this) || this;\n        _this.targetCharCodes = targetCharCodes;\n        _this.found = false;\n        return _this;\n    }\n    CharCodeFinder.prototype.visitChildren = function (node) {\n        // No need to keep looking...\n        if (this.found === true) {\n            return;\n        }\n        // switch lookaheads as they do not actually consume any characters thus\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n        switch (node.type) {\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                return;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                return;\n        }\n        _super.prototype.visitChildren.call(this, node);\n    };\n    CharCodeFinder.prototype.visitCharacter = function (node) {\n        if ((0, includes_1.default)(this.targetCharCodes, node.value)) {\n            this.found = true;\n        }\n    };\n    CharCodeFinder.prototype.visitSet = function (node) {\n        if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === undefined) {\n                this.found = true;\n            }\n        }\n        else {\n            if (findCode(node, this.targetCharCodes) !== undefined) {\n                this.found = true;\n            }\n        }\n    };\n    return CharCodeFinder;\n}(regexp_to_ast_1.BaseRegExpVisitor));\nfunction canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n        var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);\n        var charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n    }\n    else {\n        return ((0, find_1.default)(pattern, function (char) {\n            return (0, includes_1.default)(charCodes, char.charCodeAt(0));\n        }) !== undefined);\n    }\n}\nexports.canMatchCharCode = canMatchCharCode;\n//# sourceMappingURL=reg_exp.js.map"]},"metadata":{},"sourceType":"script"}