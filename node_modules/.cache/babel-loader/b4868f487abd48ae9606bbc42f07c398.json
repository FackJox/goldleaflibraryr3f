{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTokenType = exports.hasExtendingTokensTypesMapProperty = exports.hasExtendingTokensTypesProperty = exports.hasCategoriesProperty = exports.hasShortKeyProperty = exports.singleAssignCategoriesToksMap = exports.assignCategoriesMapProp = exports.assignCategoriesTokensProp = exports.assignTokenDefaultProps = exports.expandCategories = exports.augmentTokenTypes = exports.tokenIdxToClass = exports.tokenShortNameIdx = exports.tokenStructuredMatcherNoCategories = exports.tokenStructuredMatcher = void 0;\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar compact_1 = __importDefault(require(\"lodash/compact\"));\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar difference_1 = __importDefault(require(\"lodash/difference\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n  var instanceType = tokInstance.tokenTypeIdx;\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n}\nexports.tokenStructuredMatcher = tokenStructuredMatcher;\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexports.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;\nexports.tokenShortNameIdx = 1;\nexports.tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n  // collect the parent Token Types as well.\n  var tokenTypesAndParents = expandCategories(tokenTypes);\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents);\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  (0, forEach_1.default)(tokenTypesAndParents, function (tokType) {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\nexports.augmentTokenTypes = augmentTokenTypes;\nfunction expandCategories(tokenTypes) {\n  var result = (0, clone_1.default)(tokenTypes);\n  var categories = tokenTypes;\n  var searching = true;\n  while (searching) {\n    categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function (currTokType) {\n      return currTokType.CATEGORIES;\n    })));\n    var newCategories = (0, difference_1.default)(categories, result);\n    result = result.concat(newCategories);\n    if ((0, isEmpty_1.default)(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n  return result;\n}\nexports.expandCategories = expandCategories;\nfunction assignTokenDefaultProps(tokenTypes) {\n  (0, forEach_1.default)(tokenTypes, function (currTokType) {\n    if (!hasShortKeyProperty(currTokType)) {\n      exports.tokenIdxToClass[exports.tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = exports.tokenShortNameIdx++;\n    }\n    // CATEGORIES? : TokenType | TokenType[]\n    if (hasCategoriesProperty(currTokType) && !(0, isArray_1.default)(currTokType.CATEGORIES)\n    // &&\n    // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES];\n    }\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\nexports.assignTokenDefaultProps = assignTokenDefaultProps;\nfunction assignCategoriesTokensProp(tokenTypes) {\n  (0, forEach_1.default)(tokenTypes, function (currTokType) {\n    // avoid duplications\n    currTokType.categoryMatches = [];\n    (0, forEach_1.default)(currTokType.categoryMatchesMap, function (val, key) {\n      currTokType.categoryMatches.push(exports.tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\nexports.assignCategoriesTokensProp = assignCategoriesTokensProp;\nfunction assignCategoriesMapProp(tokenTypes) {\n  (0, forEach_1.default)(tokenTypes, function (currTokType) {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\nexports.assignCategoriesMapProp = assignCategoriesMapProp;\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n  (0, forEach_1.default)(path, function (pathNode) {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  (0, forEach_1.default)(nextNode.CATEGORIES, function (nextCategory) {\n    var newPath = path.concat(nextNode);\n    // avoids infinite loops due to cyclic categories.\n    if (!(0, includes_1.default)(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\nexports.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;\nfunction hasShortKeyProperty(tokType) {\n  return (0, has_1.default)(tokType, \"tokenTypeIdx\");\n}\nexports.hasShortKeyProperty = hasShortKeyProperty;\nfunction hasCategoriesProperty(tokType) {\n  return (0, has_1.default)(tokType, \"CATEGORIES\");\n}\nexports.hasCategoriesProperty = hasCategoriesProperty;\nfunction hasExtendingTokensTypesProperty(tokType) {\n  return (0, has_1.default)(tokType, \"categoryMatches\");\n}\nexports.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n  return (0, has_1.default)(tokType, \"categoryMatchesMap\");\n}\nexports.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;\nfunction isTokenType(tokType) {\n  return (0, has_1.default)(tokType, \"tokenTypeIdx\");\n}\nexports.isTokenType = isTokenType;","map":{"version":3,"sources":["../../../src/scan/tokens.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTokenType = exports.hasExtendingTokensTypesMapProperty = exports.hasExtendingTokensTypesProperty = exports.hasCategoriesProperty = exports.hasShortKeyProperty = exports.singleAssignCategoriesToksMap = exports.assignCategoriesMapProp = exports.assignCategoriesTokensProp = exports.assignTokenDefaultProps = exports.expandCategories = exports.augmentTokenTypes = exports.tokenIdxToClass = exports.tokenShortNameIdx = exports.tokenStructuredMatcherNoCategories = exports.tokenStructuredMatcher = void 0;\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar compact_1 = __importDefault(require(\"lodash/compact\"));\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar difference_1 = __importDefault(require(\"lodash/difference\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n    var instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\nexports.tokenStructuredMatcher = tokenStructuredMatcher;\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexports.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;\nexports.tokenShortNameIdx = 1;\nexports.tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    var tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    (0, forEach_1.default)(tokenTypesAndParents, function (tokType) {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nexports.augmentTokenTypes = augmentTokenTypes;\nfunction expandCategories(tokenTypes) {\n    var result = (0, clone_1.default)(tokenTypes);\n    var categories = tokenTypes;\n    var searching = true;\n    while (searching) {\n        categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function (currTokType) { return currTokType.CATEGORIES; })));\n        var newCategories = (0, difference_1.default)(categories, result);\n        result = result.concat(newCategories);\n        if ((0, isEmpty_1.default)(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nexports.expandCategories = expandCategories;\nfunction assignTokenDefaultProps(tokenTypes) {\n    (0, forEach_1.default)(tokenTypes, function (currTokType) {\n        if (!hasShortKeyProperty(currTokType)) {\n            exports.tokenIdxToClass[exports.tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = exports.tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !(0, isArray_1.default)(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nexports.assignTokenDefaultProps = assignTokenDefaultProps;\nfunction assignCategoriesTokensProp(tokenTypes) {\n    (0, forEach_1.default)(tokenTypes, function (currTokType) {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        (0, forEach_1.default)(currTokType.categoryMatchesMap, function (val, key) {\n            currTokType.categoryMatches.push(exports.tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nexports.assignCategoriesTokensProp = assignCategoriesTokensProp;\nfunction assignCategoriesMapProp(tokenTypes) {\n    (0, forEach_1.default)(tokenTypes, function (currTokType) {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nexports.assignCategoriesMapProp = assignCategoriesMapProp;\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n    (0, forEach_1.default)(path, function (pathNode) {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    (0, forEach_1.default)(nextNode.CATEGORIES, function (nextCategory) {\n        var newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!(0, includes_1.default)(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nexports.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;\nfunction hasShortKeyProperty(tokType) {\n    return (0, has_1.default)(tokType, \"tokenTypeIdx\");\n}\nexports.hasShortKeyProperty = hasShortKeyProperty;\nfunction hasCategoriesProperty(tokType) {\n    return (0, has_1.default)(tokType, \"CATEGORIES\");\n}\nexports.hasCategoriesProperty = hasCategoriesProperty;\nfunction hasExtendingTokensTypesProperty(tokType) {\n    return (0, has_1.default)(tokType, \"categoryMatches\");\n}\nexports.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n    return (0, has_1.default)(tokType, \"categoryMatchesMap\");\n}\nexports.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;\nfunction isTokenType(tokType) {\n    return (0, has_1.default)(tokType, \"tokenTypeIdx\");\n}\nexports.isTokenType = isTokenType;\n//# sourceMappingURL=tokens.js.map"]},"metadata":{},"sourceType":"script"}