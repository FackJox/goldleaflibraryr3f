{"ast":null,"code":"import _slicedToArray from \"/run/media/private/jack/Media/Projects/GoldenLeaf/LibraryR3F/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useLayoutEffect as e } from \"@radix-ui/react-use-layout-effect\";\nimport { useComposedRefs as n } from \"@radix-ui/react-compose-refs\";\nimport * as t from \"react\";\nexport var Presence = function Presence(u) {\n  var o = u.present,\n    i = u.children,\n    s = function (n) {\n      var _t$useState = t.useState(),\n        _t$useState2 = _slicedToArray(_t$useState, 2),\n        u = _t$useState2[0],\n        o = _t$useState2[1],\n        i = t.useRef({}),\n        s = t.useRef(n),\n        c = t.useRef(\"none\"),\n        a = n ? \"mounted\" : \"unmounted\",\n        _ref = function (e, n) {\n          return t.useReducer(function (e, t) {\n            var r = n[e][t];\n            return null != r ? r : e;\n          }, e);\n        }(a, {\n          mounted: {\n            UNMOUNT: \"unmounted\",\n            ANIMATION_OUT: \"unmountSuspended\"\n          },\n          unmountSuspended: {\n            MOUNT: \"mounted\",\n            ANIMATION_END: \"unmounted\"\n          },\n          unmounted: {\n            MOUNT: \"mounted\"\n          }\n        }),\n        _ref2 = _slicedToArray(_ref, 2),\n        d = _ref2[0],\n        m = _ref2[1];\n      return t.useEffect(function () {\n        var e = r(i.current);\n        c.current = \"mounted\" === d ? e : \"none\";\n      }, [d]), e(function () {\n        var e = i.current,\n          t = s.current;\n        if (t !== n) {\n          var _u = c.current,\n            _o = r(e);\n          if (n) m(\"MOUNT\");else if (\"none\" === _o || \"none\" === (null == e ? void 0 : e.display)) m(\"UNMOUNT\");else {\n            var _e = _u !== _o;\n            m(t && _e ? \"ANIMATION_OUT\" : \"UNMOUNT\");\n          }\n          s.current = n;\n        }\n      }, [n, m]), e(function () {\n        if (u) {\n          var _e2 = function _e2(e) {\n              var n = r(i.current).includes(e.animationName);\n              e.target === u && n && m(\"ANIMATION_END\");\n            },\n            _n = function _n(e) {\n              e.target === u && (c.current = r(i.current));\n            };\n          return u.addEventListener(\"animationstart\", _n), u.addEventListener(\"animationcancel\", _e2), u.addEventListener(\"animationend\", _e2), function () {\n            u.removeEventListener(\"animationstart\", _n), u.removeEventListener(\"animationcancel\", _e2), u.removeEventListener(\"animationend\", _e2);\n          };\n        }\n      }, [u, m]), {\n        isPresent: [\"mounted\", \"unmountSuspended\"].includes(d),\n        ref: t.useCallback(function (e) {\n          e && (i.current = getComputedStyle(e)), o(e);\n        }, [])\n      };\n    }(o),\n    c = \"function\" == typeof i ? i({\n      present: s.isPresent\n    }) : t.Children.only(i),\n    a = n(s.ref, c.ref);\n  return \"function\" == typeof i || s.isPresent ? /*#__PURE__*/t.cloneElement(c, {\n    ref: a\n  }) : null;\n};\nfunction r(e) {\n  return (null == e ? void 0 : e.animationName) || \"none\";\n}\nPresence.displayName = \"Presence\";","map":{"version":3,"sources":["packages/react/presence/src/Presence.tsx","packages/react/presence/src/useStateMachine.tsx"],"names":["Presence","props","present","children","presence","usePresence","child","isPresent","React","Children","only","ref","useComposedRefs","cloneElement","displayName","node","setNode","useState","stylesRef","useRef","prevPresentRef","prevAnimationNameRef","initialState","state","send","$d88c0747af12355025ed3195fb48c68a$export$useStateMachine","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","useEffect","currentAnimationName","getAnimationName","current","useLayoutEffect","styles","wasPresent","prevAnimationName","display","isAnimating","handleAnimationEnd","event","isCurrentAnimation","includes","animationName","target","handleAnimationStart","addEventListener","removeEventListener","useCallback","getComputedStyle","machine","useReducer","nextState"],"mappings":";;;;OAUA,IAAMA,QAAAA,GAAqCC,SAArCD,QAAAA,CAAqCC,CAAAA,EAAAA;EACzC,IAAQC,CAAAA,GAAsBD,CAAAA,CAAxBC,OAAAA;IAAWC,CAAAA,GAAaF,CAAAA,CAAxBC,QAAAA;IACAE,CAAAA,GAmBR,UAAqBF,CAAAA,EAAAA;MACnB,kBAAwBM,CAAAA,CAAMS,QAAAA,EAAAA;QAAAA;QAAvBF,CAAAA;QAAMC,CAAAA;QACPE,CAAAA,GAAYV,CAAAA,CAAMW,MAAAA,CAA4B,CAAA,CAAA,CAAA;QAC9CC,CAAAA,GAAiBZ,CAAAA,CAAMW,MAAAA,CAAOjB,CAAAA,CAAAA;QAC9BmB,CAAAA,GAAuBb,CAAAA,CAAMW,MAAAA,CAAe,MAAA,CAAA;QAC5CG,CAAAA,GAAepB,CAAAA,GAAU,SAAA,GAAY,WAAA;QAAA,OCzBtC,UACLoB,CAAAA,EACAgC,CAAAA,EAAAA;UAEA,OAAO9C,CAAAA,CAAM+C,UAAAA,CAAW,UAAChC,CAAAA,EAAwBqB,CAAAA,EAAAA;YAC/C,IAAMY,CAAAA,GAAaF,CAAAA,CAAQ/B,CAAAA,CAAAA,CAAeqB,CAAAA,CAAAA;YAC1C,OAAOY,IAAAA,IAAAA,CAAAA,GAAAA,CAAAA,GAAajC,CAAAA;UAAAA,CAAAA,EACnBD,CAAAA,CAAAA;QAAAA,CDmBmBG,CAAgBH,CAAAA,EAAc;UAClDI,OAAAA,EAAS;YACPC,OAAAA,EAAS,WAAA;YACTC,aAAAA,EAAe;UAAA,CAAA;UAEjBC,gBAAAA,EAAkB;YAChBC,KAAAA,EAAO,SAAA;YACPC,aAAAA,EAAe;UAAA,CAAA;UAEjBC,SAAAA,EAAW;YACTF,KAAAA,EAAO;UAAA;QAAA,CAAA,CAAA;QAAA;QAVJP,CAAAA;QAAOC,CAAAA;MAqFd,OAvEAhB,CAAAA,CAAMyB,SAAAA,CAAU,YAAA;QACd,IAAMC,CAAAA,GAAuBC,CAAAA,CAAiBjB,CAAAA,CAAUkB,OAAAA,CAAAA;QACxDf,CAAAA,CAAqBe,OAAAA,GAAoB,SAAA,KAAVb,CAAAA,GAAsBW,CAAAA,GAAuB,MAAA;MAAA,CAAA,EAC3E,CAACX,CAAAA,CAAAA,CAAAA,EAEJc,CAAAA,CAAgB,YAAA;QACd,IAAMC,CAAAA,GAASpB,CAAAA,CAAUkB,OAAAA;UACnBG,CAAAA,GAAanB,CAAAA,CAAegB,OAAAA;QAGlC,IAF0BG,CAAAA,KAAerC,CAAAA,EAElB;UACrB,IAAMsC,EAAAA,GAAoBnB,CAAAA,CAAqBe,OAAAA;YACzCF,EAAAA,GAAuBC,CAAAA,CAAiBG,CAAAA,CAAAA;UAE9C,IAAIpC,CAAAA,EACFsB,CAAAA,CAAK,OAAA,CAAA,CAAA,KACA,IAA6B,MAAA,KAAzBU,EAAAA,IAAuD,MAAA,MAApBI,IAAAA,IAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,CAAAA,CAAQG,OAAAA,CAAAA,EAGpDjB,CAAAA,CAAK,SAAA,CAAA,CAAA,KACA;YAOL,IAAMkB,EAAAA,GAAcF,EAAAA,KAAsBN,EAAAA;YAGxCV,CAAAA,CADEe,CAAAA,IAAcG,EAAAA,GACX,eAAA,GAEA,SAAA,CAAA;UAAA;UAITtB,CAAAA,CAAegB,OAAAA,GAAUlC,CAAAA;QAAAA;MAAAA,CAAAA,EAE1B,CAACA,CAAAA,EAASsB,CAAAA,CAAAA,CAAAA,EAEba,CAAAA,CAAgB,YAAA;QACd,IAAItB,CAAAA,EAAM;UAMR,IAAM4B,GAAAA,GAAsBC,SAAtBD,GAAAA,CAAsBC,CAAAA,EAAAA;cAC1B,IACMC,CAAAA,GADuBV,CAAAA,CAAiBjB,CAAAA,CAAUkB,OAAAA,CAAAA,CACRU,QAAAA,CAASF,CAAAA,CAAMG,aAAAA,CAAAA;cAC3DH,CAAAA,CAAMI,MAAAA,KAAWjC,CAAAA,IAAQ8B,CAAAA,IAC3BrB,CAAAA,CAAK,eAAA,CAAA;YAAA,CAAA;YAGHyB,EAAAA,GAAwBL,SAAxBK,EAAAA,CAAwBL,CAAAA,EAAAA;cACxBA,CAAAA,CAAMI,MAAAA,KAAWjC,CAAAA,KAEnBM,CAAAA,CAAqBe,OAAAA,GAAUD,CAAAA,CAAiBjB,CAAAA,CAAUkB,OAAAA,CAAAA,CAAAA;YAAAA,CAAAA;UAM9D,OAHArB,CAAAA,CAAKmC,gBAAAA,CAAiB,gBAAA,EAAkBD,EAAAA,CAAAA,EACxClC,CAAAA,CAAKmC,gBAAAA,CAAiB,iBAAA,EAAmBP,GAAAA,CAAAA,EACzC5B,CAAAA,CAAKmC,gBAAAA,CAAiB,cAAA,EAAgBP,GAAAA,CAAAA,EAC/B,YAAA;YACL5B,CAAAA,CAAKoC,mBAAAA,CAAoB,gBAAA,EAAkBF,EAAAA,CAAAA,EAC3ClC,CAAAA,CAAKoC,mBAAAA,CAAoB,iBAAA,EAAmBR,GAAAA,CAAAA,EAC5C5B,CAAAA,CAAKoC,mBAAAA,CAAoB,cAAA,EAAgBR,GAAAA,CAAAA;UAAAA,CAAAA;QAAAA;MAAAA,CAAAA,EAG5C,CAAC5B,CAAAA,EAAMS,CAAAA,CAAAA,CAAAA,EAEH;QACLjB,SAAAA,EAAW,CAAC,SAAA,EAAW,kBAAA,CAAA,CAAoBuC,QAAAA,CAASvB,CAAAA,CAAAA;QACpDZ,GAAAA,EAAKH,CAAAA,CAAM4C,WAAAA,CAAarC,UAAAA,CAAAA,EAAAA;UAClBA,CAAAA,KAAMG,CAAAA,CAAUkB,OAAAA,GAAUiB,gBAAAA,CAAiBtC,CAAAA,CAAAA,CAAAA,EAC/CC,CAAAA,CAAQD,CAAAA,CAAAA;QAAAA,CAAAA,EACP,EAAA;MAAA,CAAA;IAAA,CAnHYV,CAAYH,CAAAA,CAAAA;IAEvBI,CAAAA,GACgB,UAAA,IAAA,OAAbH,CAAAA,GACHA,CAAAA,CAAS;MAAED,OAAAA,EAASE,CAAAA,CAASG;IAAAA,CAAAA,CAAAA,GAC7BC,CAAAA,CAAMC,QAAAA,CAASC,IAAAA,CAAKP,CAAAA,CAAAA;IAGpBQ,CAAAA,GAAMC,CAAAA,CAAgBR,CAAAA,CAASO,GAAAA,EAAML,CAAAA,CAAcK,GAAAA,CAAAA;EAEzD,OADuC,UAAA,IAAA,OAAbR,CAAAA,IACLC,CAAAA,CAASG,SAAAA,GAAAA,aAAYC,CAAAA,CAAMK,YAAAA,CAAaP,CAAAA,EAAO;IAAEK,GAAAA,EAAAA;EAAAA,CAAAA,CAAAA,GAAS,IAAA;AAAA,CAAA;AA+GjF,SAASwB,CAAAA,CAAiBG,CAAAA,EAAAA;EACxB,OAAA,CAAOA,IAAAA,IAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,CAAAA,CAAQS,aAAAA,KAAiB,MAAA;AAAA;AA7GlC/C,QAAAA,CAASc,WAAAA,GAAc,UAAA","sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './useStateMachine';\n\ninterface PresenceProps {\n  present: boolean;\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement;\n\n  const ref = useComposedRefs(presence.ref, (child as any).ref);\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration>({} as any);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          send('ANIMATION_END');\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName || 'none';\n}\n\nexport { Presence };\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// 🤯 https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n"]},"metadata":{},"sourceType":"module"}