{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attemptInRepetitionRecovery = exports.Recoverable = exports.InRuleRecoveryException = exports.IN_RULE_RECOVERY_EXCEPTION = exports.EOF_FOLLOW_KEY = void 0;\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar find_1 = __importDefault(require(\"lodash/find\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar exceptions_public_1 = require(\"../../exceptions_public\");\nvar constants_1 = require(\"../../constants\");\nvar parser_1 = require(\"../parser\");\nexports.EOF_FOLLOW_KEY = {};\nexports.IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nvar InRuleRecoveryException = /** @class */function (_super) {\n  __extends(InRuleRecoveryException, _super);\n  function InRuleRecoveryException(message) {\n    var _this = _super.call(this, message) || this;\n    _this.name = exports.IN_RULE_RECOVERY_EXCEPTION;\n    return _this;\n  }\n  return InRuleRecoveryException;\n}(Error);\nexports.InRuleRecoveryException = InRuleRecoveryException;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nvar Recoverable = /** @class */function () {\n  function Recoverable() {}\n  Recoverable.prototype.initRecoverable = function (config) {\n    this.firstAfterRepMap = {};\n    this.resyncFollows = {};\n    this.recoveryEnabled = (0, has_1.default)(config, \"recoveryEnabled\") ? config.recoveryEnabled // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;\n    // performance optimization, NOOP will be inlined which\n    // effectively means that this optional feature does not exist\n    // when not used.\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n    }\n  };\n  Recoverable.prototype.getTokenToInsert = function (tokType) {\n    var tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n    tokToInsert.isInsertedInRecovery = true;\n    return tokToInsert;\n  };\n  Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n    return true;\n  };\n  Recoverable.prototype.canTokenTypeBeDeletedInRecovery = function (tokType) {\n    return true;\n  };\n  Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n    var _this = this;\n    // TODO: can the resyncTokenType be cached?\n    var reSyncTokType = this.findReSyncTokenType();\n    var savedLexerState = this.exportLexerState();\n    var resyncedTokens = [];\n    var passedResyncPoint = false;\n    var nextTokenWithoutResync = this.LA(1);\n    var currToken = this.LA(1);\n    var generateErrorMessage = function generateErrorMessage() {\n      var previousToken = _this.LA(0);\n      // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n      // the error that would have been thrown\n      var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: _this.getCurrRuleFullName()\n      });\n      var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));\n      // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n      error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);\n      _this.SAVE_ERROR(error);\n    };\n    while (!passedResyncPoint) {\n      // re-synced to a point where we can safely exit the repetition/\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage();\n        return; // must return here to avoid reverting the inputIdx\n      } else if (lookAheadFunc.call(this)) {\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n        generateErrorMessage();\n        // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n        grammarRule.apply(this, grammarRuleArgs);\n        return; // must return here to avoid reverting the inputIdx\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true;\n      } else {\n        currToken = this.SKIP_TOKEN();\n        this.addToResyncTokens(currToken, resyncedTokens);\n      }\n    }\n    // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n    // \"between rules\" resync recovery later in the flow.\n    this.importLexerState(savedLexerState);\n  };\n  Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n    // Edge case of arriving from a MANY repetition which is stuck\n    // Attempting recovery in this case could cause an infinite loop\n    if (notStuck === false) {\n      return false;\n    }\n    // no need to recover, next token is what we expect...\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false;\n    }\n    // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n    // and prefer some backtracking path that includes recovered errors.\n    if (this.isBackTracking()) {\n      return false;\n    }\n    // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n    //noinspection RedundantIfStatementJS\n    if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n      return false;\n    }\n    return true;\n  };\n  // Error Recovery functionality\n  Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n    var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n    var follows = this.getNextPossibleTokenTypes(grammarPath);\n    return follows;\n  };\n  Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      var tokToInsert = this.getTokenToInsert(expectedTokType);\n      return tokToInsert;\n    }\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      var nextTok = this.SKIP_TOKEN();\n      this.consumeToken();\n      return nextTok;\n    }\n    throw new InRuleRecoveryException(\"sad sad panda\");\n  };\n  Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n    return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n  };\n  Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n    var _this = this;\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false;\n    }\n    // must know the possible following tokens to perform single token insertion\n    if ((0, isEmpty_1.default)(follows)) {\n      return false;\n    }\n    var mismatchedTok = this.LA(1);\n    var isMisMatchedTokInFollows = (0, find_1.default)(follows, function (possibleFollowsTokType) {\n      return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n    }) !== undefined;\n    return isMisMatchedTokInFollows;\n  };\n  Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n    if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n      return false;\n    }\n    var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n    return isNextTokenWhatIsExpected;\n  };\n  Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n    var followKey = this.getCurrFollowKey();\n    var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n    return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);\n  };\n  Recoverable.prototype.findReSyncTokenType = function () {\n    var allPossibleReSyncTokTypes = this.flattenFollowSet();\n    // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n    var nextToken = this.LA(1);\n    var k = 2;\n    while (true) {\n      var foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, function (resyncTokType) {\n        var canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);\n        return canMatch;\n      });\n      if (foundMatch !== undefined) {\n        return foundMatch;\n      }\n      nextToken = this.LA(k);\n      k++;\n    }\n  };\n  Recoverable.prototype.getCurrFollowKey = function () {\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n    if (this.RULE_STACK.length === 1) {\n      return exports.EOF_FOLLOW_KEY;\n    }\n    var currRuleShortName = this.getLastExplicitRuleShortName();\n    var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n    var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    };\n  };\n  Recoverable.prototype.buildFullFollowKeyStack = function () {\n    var _this = this;\n    var explicitRuleStack = this.RULE_STACK;\n    var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return (0, map_1.default)(explicitRuleStack, function (ruleName, idx) {\n      if (idx === 0) {\n        return exports.EOF_FOLLOW_KEY;\n      }\n      return {\n        ruleName: _this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      };\n    });\n  };\n  Recoverable.prototype.flattenFollowSet = function () {\n    var _this = this;\n    var followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), function (currKey) {\n      return _this.getFollowSetFromFollowKey(currKey);\n    });\n    return (0, flatten_1.default)(followStack);\n  };\n  Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n    if (followKey === exports.EOF_FOLLOW_KEY) {\n      return [tokens_public_1.EOF];\n    }\n    var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;\n    return this.resyncFollows[followName];\n  };\n  // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n  Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n    if (!this.tokenMatcher(token, tokens_public_1.EOF)) {\n      resyncTokens.push(token);\n    }\n    return resyncTokens;\n  };\n  Recoverable.prototype.reSyncTo = function (tokType) {\n    var resyncedTokens = [];\n    var nextTok = this.LA(1);\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN();\n      this.addToResyncTokens(nextTok, resyncedTokens);\n    }\n    // the last token is not part of the error.\n    return (0, dropRight_1.default)(resyncedTokens);\n  };\n  Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    // by default this is a NO-OP\n    // The actual implementation is with the function(not method) below\n  };\n  Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n    var pathRuleStack = this.getHumanReadableRuleStack();\n    var pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);\n    var grammarPath = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    };\n    return grammarPath;\n  };\n  Recoverable.prototype.getHumanReadableRuleStack = function () {\n    var _this = this;\n    return (0, map_1.default)(this.RULE_STACK, function (currShortName) {\n      return _this.shortRuleNameToFullName(currShortName);\n    });\n  };\n  return Recoverable;\n}();\nexports.Recoverable = Recoverable;\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n  var firstAfterRepInfo = this.firstAfterRepMap[key];\n  if (firstAfterRepInfo === undefined) {\n    var currRuleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[currRuleName];\n    var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n    firstAfterRepInfo = walker.startWalking();\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\n  }\n  var expectTokAfterLastMatch = firstAfterRepInfo.token;\n  var nextTokIdx = firstAfterRepInfo.occurrence;\n  var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n  // special edge case of a TOP most repetition after which the input should END.\n  // this will force an attempt for inRule recovery in that scenario.\n  if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === undefined) {\n    expectTokAfterLastMatch = tokens_public_1.EOF;\n    nextTokIdx = 1;\n  }\n  // We don't have anything to re-sync to...\n  // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n  if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n    return;\n  }\n  if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n    // TODO: performance optimization: instead of passing the original args here, we modify\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n    // to avoid searching the cache for it once more.\n    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n  }\n}\nexports.attemptInRepetitionRecovery = attemptInRepetitionRecovery;","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/recoverable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.attemptInRepetitionRecovery = exports.Recoverable = exports.InRuleRecoveryException = exports.IN_RULE_RECOVERY_EXCEPTION = exports.EOF_FOLLOW_KEY = void 0;\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar find_1 = __importDefault(require(\"lodash/find\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar exceptions_public_1 = require(\"../../exceptions_public\");\nvar constants_1 = require(\"../../constants\");\nvar parser_1 = require(\"../parser\");\nexports.EOF_FOLLOW_KEY = {};\nexports.IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nvar InRuleRecoveryException = /** @class */ (function (_super) {\n    __extends(InRuleRecoveryException, _super);\n    function InRuleRecoveryException(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = exports.IN_RULE_RECOVERY_EXCEPTION;\n        return _this;\n    }\n    return InRuleRecoveryException;\n}(Error));\nexports.InRuleRecoveryException = InRuleRecoveryException;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nvar Recoverable = /** @class */ (function () {\n    function Recoverable() {\n    }\n    Recoverable.prototype.initRecoverable = function (config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = (0, has_1.default)(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    };\n    Recoverable.prototype.getTokenToInsert = function (tokType) {\n        var tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    };\n    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n        return true;\n    };\n    Recoverable.prototype.canTokenTypeBeDeletedInRecovery = function (tokType) {\n        return true;\n    };\n    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        var _this = this;\n        // TODO: can the resyncTokenType be cached?\n        var reSyncTokType = this.findReSyncTokenType();\n        var savedLexerState = this.exportLexerState();\n        var resyncedTokens = [];\n        var passedResyncPoint = false;\n        var nextTokenWithoutResync = this.LA(1);\n        var currToken = this.LA(1);\n        var generateErrorMessage = function () {\n            var previousToken = _this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: _this.getCurrRuleFullName()\n            });\n            var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);\n            _this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    };\n    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    };\n    // Error Recovery functionality\n    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        var follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    };\n    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            var tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            var nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    };\n    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n        var _this = this;\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if ((0, isEmpty_1.default)(follows)) {\n            return false;\n        }\n        var mismatchedTok = this.LA(1);\n        var isMisMatchedTokInFollows = (0, find_1.default)(follows, function (possibleFollowsTokType) {\n            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n            return false;\n        }\n        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    };\n    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n        var followKey = this.getCurrFollowKey();\n        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);\n    };\n    Recoverable.prototype.findReSyncTokenType = function () {\n        var allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        var nextToken = this.LA(1);\n        var k = 2;\n        while (true) {\n            var foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, function (resyncTokType) {\n                var canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);\n                return canMatch;\n            });\n            if (foundMatch !== undefined) {\n                return foundMatch;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    };\n    Recoverable.prototype.getCurrFollowKey = function () {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return exports.EOF_FOLLOW_KEY;\n        }\n        var currRuleShortName = this.getLastExplicitRuleShortName();\n        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n        };\n    };\n    Recoverable.prototype.buildFullFollowKeyStack = function () {\n        var _this = this;\n        var explicitRuleStack = this.RULE_STACK;\n        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return (0, map_1.default)(explicitRuleStack, function (ruleName, idx) {\n            if (idx === 0) {\n                return exports.EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: _this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n        });\n    };\n    Recoverable.prototype.flattenFollowSet = function () {\n        var _this = this;\n        var followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), function (currKey) {\n            return _this.getFollowSetFromFollowKey(currKey);\n        });\n        return (0, flatten_1.default)(followStack);\n    };\n    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n        if (followKey === exports.EOF_FOLLOW_KEY) {\n            return [tokens_public_1.EOF];\n        }\n        var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    };\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n        if (!this.tokenMatcher(token, tokens_public_1.EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    };\n    Recoverable.prototype.reSyncTo = function (tokType) {\n        var resyncedTokens = [];\n        var nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return (0, dropRight_1.default)(resyncedTokens);\n    };\n    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    };\n    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n        var pathRuleStack = this.getHumanReadableRuleStack();\n        var pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);\n        var grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n        };\n        return grammarPath;\n    };\n    Recoverable.prototype.getHumanReadableRuleStack = function () {\n        var _this = this;\n        return (0, map_1.default)(this.RULE_STACK, function (currShortName) {\n            return _this.shortRuleNameToFullName(currShortName);\n        });\n    };\n    return Recoverable;\n}());\nexports.Recoverable = Recoverable;\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    var firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        var currRuleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[currRuleName];\n        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    var expectTokAfterLastMatch = firstAfterRepInfo.token;\n    var nextTokIdx = firstAfterRepInfo.occurrence;\n    var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = tokens_public_1.EOF;\n        nextTokIdx = 1;\n    }\n    // We don't have anything to re-sync to...\n    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n        return;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\nexports.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n//# sourceMappingURL=recoverable.js.map"]},"metadata":{},"sourceType":"script"}