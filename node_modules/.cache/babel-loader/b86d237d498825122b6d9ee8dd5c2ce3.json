{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RecognizerEngine = void 0;\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar every_1 = __importDefault(require(\"lodash/every\"));\nvar uniq_1 = __importDefault(require(\"lodash/uniq\"));\nvar isObject_1 = __importDefault(require(\"lodash/isObject\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar values_1 = __importDefault(require(\"lodash/values\"));\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar keys_1 = require(\"../../grammar/keys\");\nvar exceptions_public_1 = require(\"../../exceptions_public\");\nvar lookahead_1 = require(\"../../grammar/lookahead\");\nvar interpreter_1 = require(\"../../grammar/interpreter\");\nvar parser_1 = require(\"../parser\");\nvar recoverable_1 = require(\"./recoverable\");\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar tokens_1 = require(\"../../../scan/tokens\");\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nvar RecognizerEngine = /** @class */function () {\n  function RecognizerEngine() {}\n  RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n    this.className = this.constructor.name;\n    // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;\n    this.subruleIdx = 0;\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n    if ((0, has_1.default)(config, \"serializedGrammar\")) {\n      throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" + \"\\tFor Further details.\");\n    }\n    if ((0, isArray_1.default)(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if ((0, isEmpty_1.default)(tokenVocabulary)) {\n        throw Error(\"A Token Vocabulary cannot be empty.\\n\" + \"\\tNote that the first argument for the parser constructor\\n\" + \"\\tis no longer a Token vector (since v4.0).\");\n      }\n      if (typeof tokenVocabulary[0].startOffset === \"number\") {\n        throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" + \"\\tFor Further details.\");\n      }\n    }\n    if ((0, isArray_1.default)(tokenVocabulary)) {\n      this.tokensMap = (0, reduce_1.default)(tokenVocabulary, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if ((0, has_1.default)(tokenVocabulary, \"modes\") && (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {\n      var allTokenTypes_1 = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));\n      var uniqueTokens = (0, uniq_1.default)(allTokenTypes_1);\n      this.tokensMap = (0, reduce_1.default)(uniqueTokens, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if ((0, isObject_1.default)(tokenVocabulary)) {\n      this.tokensMap = (0, clone_1.default)(tokenVocabulary);\n    } else {\n      throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" + \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n    }\n    // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n    this.tokensMap[\"EOF\"] = tokens_public_1.EOF;\n    var allTokenTypes = (0, has_1.default)(tokenVocabulary, \"modes\") ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)) : (0, values_1.default)(tokenVocabulary);\n    var noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, function (tokenConstructor) {\n      return (0, isEmpty_1.default)(tokenConstructor.categoryMatches);\n    });\n    this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;\n    // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n    (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));\n  };\n  RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n    if (this.selfAnalysisDone) {\n      throw Error(\"Grammar rule <\".concat(ruleName, \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\") + \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n    }\n    var resyncEnabled = (0, has_1.default)(config, \"resyncEnabled\") ? config.resyncEnabled // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;\n    var recoveryValueFunc = (0, has_1.default)(config, \"recoveryValueFunc\") ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;\n    // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n    var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n    var invokeRuleWithTry;\n    // Micro optimization, only check the condition **once** on rule definition\n    // instead of **every single** rule invocation.\n    if (this.outputCst === true) {\n      invokeRuleWithTry = function invokeRuleWithTry() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          impl.apply(this, args);\n          var cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst;\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    } else {\n      invokeRuleWithTry = function invokeRuleWithTryCst() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          return impl.apply(this, args);\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    }\n    var wrappedGrammarRule = Object.assign(invokeRuleWithTry, {\n      ruleName: ruleName,\n      originalGrammarAction: impl\n    });\n    return wrappedGrammarRule;\n  };\n  RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n    var isFirstInvokedRule = this.RULE_STACK.length === 1;\n    // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n    var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n    if ((0, exceptions_public_1.isRecognitionException)(e)) {\n      var recogError = e;\n      if (reSyncEnabled) {\n        var reSyncTokType = this.findReSyncTokenType();\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc();\n          }\n        } else {\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          }\n          // to be handled Further up the call stack\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState();\n        // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n        return recoveryValueFunc();\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError;\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e;\n    }\n  };\n  // Implementation of parsing DSL\n  RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n    var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  };\n  RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n    var _this = this;\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      var predicate_1 = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate_1 !== undefined) {\n        var orgLookaheadFunction_1 = lookAheadFunc;\n        lookAheadFunc = function lookAheadFunc() {\n          return predicate_1.call(_this) && orgLookaheadFunction_1.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n    return undefined;\n  };\n  RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);\n    return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n  RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      var predicate_2 = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate_2 !== undefined) {\n        var orgLookaheadFunction_2 = lookAheadFunc;\n        lookAheadFunc = function lookAheadFunc() {\n          return predicate_2.call(_this) && orgLookaheadFunction_2.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      var notStuck = this.doSingleRepetition(action);\n      while (lookAheadFunc.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n    }\n    // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);\n  };\n  RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n  RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n    // 1st iteration\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;\n      action.call(this);\n      //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n      var separatorLookAheadFunc = function separatorLookAheadFunc() {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      };\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        action.call(this);\n      }\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterAtLeastOneSepWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n  };\n  RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n  RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n    var lookaheadFunction = this.getLaFuncFromCache(key);\n    var action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      var predicate_3 = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate_3 !== undefined) {\n        var orgLookaheadFunction_3 = lookaheadFunction;\n        lookaheadFunction = function lookaheadFunction() {\n          return predicate_3.call(_this) && orgLookaheadFunction_3.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    var notStuck = true;\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    }\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, keys_1.MANY_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManyWalker,\n    // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n    // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n    // An infinite loop cannot occur as:\n    // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n    // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n    notStuck);\n  };\n  RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n  RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLaFunc = this.getLaFuncFromCache(key);\n    // 1st iteration\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n      var separatorLookAheadFunc = function separatorLookAheadFunc() {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      };\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        // No need for checking infinite loop here due to consuming the separator.\n        action.call(this);\n      }\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterManySepWalker], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);\n    }\n  };\n  RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator);\n      action.call(this);\n    }\n    // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    /* istanbul ignore else */\n    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n  };\n  RecognizerEngine.prototype.doSingleRepetition = function (action) {\n    var beforeIteration = this.getLexerPosition();\n    action.call(this);\n    var afterIteration = this.getLexerPosition();\n    // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n    return afterIteration > beforeIteration;\n  };\n  RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);\n    var alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n    var laFunc = this.getLaFuncFromCache(laKey);\n    var altIdxToTake = laFunc.call(this, alts);\n    if (altIdxToTake !== undefined) {\n      var chosenAlternative = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n  };\n  RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop();\n    // NOOP when cst is disabled\n    this.cstFinallyStateUpdate();\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      var firstRedundantTok = this.LA(1);\n      var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      });\n      this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));\n    }\n  };\n  RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n    var ruleResult;\n    try {\n      var args = options !== undefined ? options.ARGS : undefined;\n      this.subruleIdx = idx;\n      ruleResult = ruleToCall.apply(this, args);\n      this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName);\n      return ruleResult;\n    } catch (e) {\n      throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  };\n  RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n    if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName);\n      delete e.partialCstResult;\n    }\n    throw e;\n  };\n  RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n    var consumedToken;\n    try {\n      var nextToken = this.LA(1);\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n    }\n    this.cstPostTerminal(options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name, consumedToken);\n    return consumedToken;\n  };\n  RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n    var msg;\n    var previousToken = this.LA(0);\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n    }\n    throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));\n  };\n  RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (this.recoveryEnabled &&\n    // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n    eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n      var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n      try {\n        return this.tryInRuleRecovery(tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  };\n  RecognizerEngine.prototype.saveRecogState = function () {\n    // errors is a getter which will clone the errors array\n    var savedErrors = this.errors;\n    var savedRuleStack = (0, clone_1.default)(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    };\n  };\n  RecognizerEngine.prototype.reloadRecogState = function (newState) {\n    this.errors = newState.errors;\n    this.importLexerState(newState.lexerState);\n    this.RULE_STACK = newState.RULE_STACK;\n  };\n  RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName);\n    // NOOP when cst is disabled\n    this.cstInvocationStateUpdate(fullName);\n  };\n  RecognizerEngine.prototype.isBackTracking = function () {\n    return this.isBackTrackingStack.length !== 0;\n  };\n  RecognizerEngine.prototype.getCurrRuleFullName = function () {\n    var shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  };\n  RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n    return this.shortRuleNameToFull[shortName];\n  };\n  RecognizerEngine.prototype.isAtEndOfInput = function () {\n    return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);\n  };\n  RecognizerEngine.prototype.reset = function () {\n    this.resetLexerState();\n    this.subruleIdx = 0;\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = [];\n    // TODO: extract a specific reset for TreeBuilder trait\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  };\n  return RecognizerEngine;\n}();\nexports.RecognizerEngine = RecognizerEngine;","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/recognizer_engine.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RecognizerEngine = void 0;\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar every_1 = __importDefault(require(\"lodash/every\"));\nvar uniq_1 = __importDefault(require(\"lodash/uniq\"));\nvar isObject_1 = __importDefault(require(\"lodash/isObject\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar values_1 = __importDefault(require(\"lodash/values\"));\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar keys_1 = require(\"../../grammar/keys\");\nvar exceptions_public_1 = require(\"../../exceptions_public\");\nvar lookahead_1 = require(\"../../grammar/lookahead\");\nvar interpreter_1 = require(\"../../grammar/interpreter\");\nvar parser_1 = require(\"../parser\");\nvar recoverable_1 = require(\"./recoverable\");\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar tokens_1 = require(\"../../../scan/tokens\");\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nvar RecognizerEngine = /** @class */ (function () {\n    function RecognizerEngine() {\n    }\n    RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n        this.className = this.constructor.name;\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;\n        this.subruleIdx = 0;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if ((0, has_1.default)(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if ((0, isArray_1.default)(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if ((0, isEmpty_1.default)(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if ((0, isArray_1.default)(tokenVocabulary)) {\n            this.tokensMap = (0, reduce_1.default)(tokenVocabulary, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if ((0, has_1.default)(tokenVocabulary, \"modes\") &&\n            (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {\n            var allTokenTypes_1 = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));\n            var uniqueTokens = (0, uniq_1.default)(allTokenTypes_1);\n            this.tokensMap = (0, reduce_1.default)(uniqueTokens, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if ((0, isObject_1.default)(tokenVocabulary)) {\n            this.tokensMap = (0, clone_1.default)(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        this.tokensMap[\"EOF\"] = tokens_public_1.EOF;\n        var allTokenTypes = (0, has_1.default)(tokenVocabulary, \"modes\")\n            ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes))\n            : (0, values_1.default)(tokenVocabulary);\n        var noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, function (tokenConstructor) {\n            return (0, isEmpty_1.default)(tokenConstructor.categoryMatches);\n        });\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? tokens_1.tokenStructuredMatcherNoCategories\n            : tokens_1.tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));\n    };\n    RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(\"Grammar rule <\".concat(ruleName, \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\") +\n                \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n        }\n        var resyncEnabled = (0, has_1.default)(config, \"resyncEnabled\")\n            ? config.resyncEnabled // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;\n        var recoveryValueFunc = (0, has_1.default)(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        var shortName = this.ruleShortNameIdx << (keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX);\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        var invokeRuleWithTry;\n        // Micro optimization, only check the condition **once** on rule definition\n        // instead of **every single** rule invocation.\n        if (this.outputCst === true) {\n            invokeRuleWithTry = function invokeRuleWithTry() {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    impl.apply(this, args);\n                    var cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        else {\n            invokeRuleWithTry = function invokeRuleWithTryCst() {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    return impl.apply(this, args);\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        var wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName: ruleName, originalGrammarAction: impl });\n        return wrappedGrammarRule;\n    };\n    RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n        var isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n        if ((0, exceptions_public_1.isRecognitionException)(e)) {\n            var recogError = e;\n            if (reSyncEnabled) {\n                var reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc();\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc();\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    };\n    // Implementation of parsing DSL\n    RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n        var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    };\n    RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate_1 = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate_1 !== undefined) {\n                var orgLookaheadFunction_1 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return predicate_1.call(_this) && orgLookaheadFunction_1.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    };\n    RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    };\n    RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate_2 = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate_2 !== undefined) {\n                var orgLookaheadFunction_2 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return predicate_2.call(_this) && orgLookaheadFunction_2.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            var notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            ;\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                interpreter_1.NextTerminalAfterAtLeastOneSepWalker\n            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    };\n    RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    };\n    RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookaheadFunction = this.getLaFuncFromCache(key);\n        var action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate_3 = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate_3 !== undefined) {\n                var orgLookaheadFunction_3 = lookaheadFunction;\n                lookaheadFunction = function () {\n                    return predicate_3.call(_this) && orgLookaheadFunction_3.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        var notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, keys_1.MANY_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    };\n    RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                interpreter_1.NextTerminalAfterManySepWalker\n            ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);\n        }\n    };\n    RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker\n        ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    };\n    RecognizerEngine.prototype.doSingleRepetition = function (action) {\n        var beforeIteration = this.getLexerPosition();\n        action.call(this);\n        var afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    };\n    RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);\n        var alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n        var laFunc = this.getLaFuncFromCache(laKey);\n        var altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            var chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    };\n    RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            var firstRedundantTok = this.LA(1);\n            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName()\n            });\n            this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    };\n    RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n        var ruleResult;\n        try {\n            var args = options !== undefined ? options.ARGS : undefined;\n            this.subruleIdx = idx;\n            ruleResult = ruleToCall.apply(this, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    };\n    RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n        if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    };\n    RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n        var consumedToken;\n        try {\n            var nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    };\n    RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n        var msg;\n        var previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName()\n            });\n        }\n        throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));\n    };\n    RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    };\n    RecognizerEngine.prototype.saveRecogState = function () {\n        // errors is a getter which will clone the errors array\n        var savedErrors = this.errors;\n        var savedRuleStack = (0, clone_1.default)(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK\n        };\n    };\n    RecognizerEngine.prototype.reloadRecogState = function (newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    };\n    RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName);\n    };\n    RecognizerEngine.prototype.isBackTracking = function () {\n        return this.isBackTrackingStack.length !== 0;\n    };\n    RecognizerEngine.prototype.getCurrRuleFullName = function () {\n        var shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.isAtEndOfInput = function () {\n        return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);\n    };\n    RecognizerEngine.prototype.reset = function () {\n        this.resetLexerState();\n        this.subruleIdx = 0;\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        // TODO: extract a specific reset for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    };\n    return RecognizerEngine;\n}());\nexports.RecognizerEngine = RecognizerEngine;\n//# sourceMappingURL=recognizer_engine.js.map"]},"metadata":{},"sourceType":"script"}