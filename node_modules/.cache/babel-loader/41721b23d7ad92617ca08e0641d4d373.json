{"ast":null,"code":"import _toConsumableArray from \"/run/media/private/jack/Media/Projects/GoldenLeaf/LibraryR3F/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/run/media/private/jack/Media/Projects/GoldenLeaf/LibraryR3F/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/run/media/private/jack/Media/Projects/GoldenLeaf/LibraryR3F/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/run/media/private/jack/Media/Projects/GoldenLeaf/LibraryR3F/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/run/media/private/jack/Media/Projects/GoldenLeaf/LibraryR3F/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { EventQueue, RigidBodyDesc, ColliderDesc, ActiveEvents, ShapeType } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport React, { useRef, useState, useEffect, useMemo, createContext, useContext, memo, forwardRef, useImperativeHandle, useLayoutEffect } from 'react';\nimport { useAsset } from 'use-asset';\nimport { useFrame } from '@react-three/fiber';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, MathUtils, InstancedMesh, MeshBasicMaterial, Color, PlaneGeometry, ConeGeometry, CapsuleGeometry, CylinderGeometry, BufferGeometry, BufferAttribute, SphereGeometry, BoxGeometry, DynamicDrawUsage } from 'three';\nimport { mergeVertices, RoundedBoxGeometry } from 'three-stdlib';\nvar _quaternion = new Quaternion();\nnew Euler();\nvar _vector3 = new Vector3();\nvar _object3d = new Object3D();\nvar _matrix4 = new Matrix4();\nvar _position = new Vector3();\nvar _rotation = new Quaternion();\nvar _scale = new Vector3();\nvar vectorArrayToVector3 = function vectorArrayToVector3(arr) {\n  var _arr = _slicedToArray(arr, 3),\n    x = _arr[0],\n    y = _arr[1],\n    z = _arr[2];\n  return new Vector3(x, y, z);\n};\nvar rapierVector3ToVector3 = function rapierVector3ToVector3(_ref) {\n  var x = _ref.x,\n    y = _ref.y,\n    z = _ref.z;\n  return _vector3.set(x, y, z);\n};\nvar rapierQuaternionToQuaternion = function rapierQuaternionToQuaternion(_ref2) {\n  var x = _ref2.x,\n    y = _ref2.y,\n    z = _ref2.z,\n    w = _ref2.w;\n  return _quaternion.set(x, y, z, w);\n};\nvar rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nvar rigidBodyTypeFromString = function rigidBodyTypeFromString(type) {\n  return rigidBodyTypeMap[type];\n};\nvar scaleVertices = function scaleVertices(vertices, scale) {\n  var scaledVerts = Array.from(vertices);\n  for (var i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nvar vectorToTuple = function vectorToTuple(v) {\n  if (!v) return [0];\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nvar createRigidBodyApi = function createRigidBodyApi(ref) {\n  return {\n    raw: function raw() {\n      return ref.current();\n    },\n    get handle() {\n      return ref.current().handle;\n    },\n    mass: function mass() {\n      return ref.current().mass();\n    },\n    applyImpulse: function applyImpulse(impulseVector) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      ref.current().applyImpulse(impulseVector, wakeUp);\n    },\n    applyTorqueImpulse: function applyTorqueImpulse(torqueVector) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      ref.current().applyTorqueImpulse(torqueVector, wakeUp);\n    },\n    applyImpulseAtPoint: function applyImpulseAtPoint(impulseVector, impulsePoint) {\n      var wakeUp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return ref.current().applyImpulseAtPoint(impulseVector, impulsePoint, wakeUp);\n    },\n    addForce: function addForce(force) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return ref.current().addForce(force, wakeUp);\n    },\n    addForceAtPoint: function addForceAtPoint(force, point) {\n      var wakeUp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return ref.current().addForceAtPoint(force, point, wakeUp);\n    },\n    addTorque: function addTorque(torque) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return ref.current().addTorque(torque, wakeUp);\n    },\n    translation: function translation() {\n      return rapierVector3ToVector3(ref.current().translation());\n    },\n    setTranslation: function setTranslation(translation) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return ref.current().setTranslation(translation, wakeUp);\n    },\n    rotation: function rotation() {\n      var _ref$current$rotation = ref.current().rotation(),\n        x = _ref$current$rotation.x,\n        y = _ref$current$rotation.y,\n        z = _ref$current$rotation.z,\n        w = _ref$current$rotation.w;\n      return new Quaternion(x, y, z, w);\n    },\n    setRotation: function setRotation(rotation) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      ref.current().setRotation(rotation, wakeUp);\n    },\n    linvel: function linvel() {\n      var _ref$current$linvel = ref.current().linvel(),\n        x = _ref$current$linvel.x,\n        y = _ref$current$linvel.y,\n        z = _ref$current$linvel.z;\n      return new Vector3(x, y, z);\n    },\n    setLinvel: function setLinvel(velocity) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return ref.current().setLinvel(velocity, wakeUp);\n    },\n    angvel: function angvel() {\n      var _ref$current$angvel = ref.current().angvel(),\n        x = _ref$current$angvel.x,\n        y = _ref$current$angvel.y,\n        z = _ref$current$angvel.z;\n      return new Vector3(x, y, z);\n    },\n    setAngvel: function setAngvel(velocity) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return ref.current().setAngvel(velocity, wakeUp);\n    },\n    linearDamping: function linearDamping() {\n      return ref.current().linearDamping();\n    },\n    setLinearDamping: function setLinearDamping(factor) {\n      return ref.current().setLinearDamping(factor);\n    },\n    angularDamping: function angularDamping() {\n      return ref.current().angularDamping();\n    },\n    setAngularDamping: function setAngularDamping(factor) {\n      return ref.current().setAngularDamping(factor);\n    },\n    setNextKinematicRotation: function setNextKinematicRotation(rotation) {\n      ref.current().setNextKinematicRotation(rotation);\n    },\n    setNextKinematicTranslation: function setNextKinematicTranslation(translation) {\n      return ref.current().setNextKinematicTranslation(translation);\n    },\n    resetForces: function resetForces() {\n      var wakeUp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return ref.current().resetForces(wakeUp);\n    },\n    resetTorques: function resetTorques() {\n      var wakeUp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return ref.current().resetTorques(wakeUp);\n    },\n    lockRotations: function lockRotations(locked) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return ref.current().lockRotations(locked, wakeUp);\n    },\n    lockTranslations: function lockTranslations(locked) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return ref.current().lockTranslations(locked, wakeUp);\n    },\n    setEnabledRotations: function setEnabledRotations(x, y, z) {\n      var wakeUp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      return ref.current().setEnabledRotations(x, y, z, wakeUp);\n    },\n    setEnabledTranslations: function setEnabledTranslations(x, y, z) {\n      var wakeUp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      return ref.current().setEnabledTranslations(x, y, z, wakeUp);\n    }\n  };\n};\nvar createInstancedRigidBodiesApi = function createInstancedRigidBodiesApi(bodiesGetter) {\n  return {\n    at: function at(index) {\n      return bodiesGetter.current()[index].api;\n    },\n    forEach: function forEach(callback) {\n      return bodiesGetter.current().map(function (b) {\n        return b.api;\n      }).forEach(callback);\n    },\n    get count() {\n      return bodiesGetter.current().length;\n    }\n  };\n}; // TODO: Flesh this out\nvar createWorldApi = function createWorldApi(ref) {\n  return {\n    raw: function raw() {\n      return ref.current();\n    },\n    getCollider: function getCollider(handle) {\n      return ref.current().getCollider(handle);\n    },\n    getRigidBody: function getRigidBody(handle) {\n      return ref.current().getRigidBody(handle);\n    },\n    createRigidBody: function createRigidBody(desc) {\n      return ref.current().createRigidBody(desc);\n    },\n    createCollider: function createCollider(desc, rigidBody) {\n      return ref.current().createCollider(desc, rigidBody);\n    },\n    removeRigidBody: function removeRigidBody(rigidBody) {\n      if (!ref.current().bodies.contains(rigidBody.handle)) return;\n      ref.current().removeRigidBody(rigidBody);\n    },\n    removeCollider: function removeCollider(collider) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (!ref.current().colliders.contains(collider.handle)) return;\n      ref.current().removeCollider(collider, wakeUp);\n    },\n    createImpulseJoint: function createImpulseJoint(params, rigidBodyA, rigidBodyB) {\n      var wakeUp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      return ref.current().createImpulseJoint(params, rigidBodyA, rigidBodyB, wakeUp);\n    },\n    removeImpulseJoint: function removeImpulseJoint(joint) {\n      var wakeUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (!ref.current().impulseJoints.contains(joint.handle)) return;\n      ref.current().removeImpulseJoint(joint, wakeUp);\n    },\n    forEachCollider: function forEachCollider(callback) {\n      return ref.current().forEachCollider(callback);\n    },\n    setGravity: function setGravity(_ref3) {\n      var x = _ref3.x,\n        y = _ref3.y,\n        z = _ref3.z;\n      return ref.current().gravity = {\n        x: x,\n        y: y,\n        z: z\n      };\n    }\n  };\n}; // TODO: Broken currently, waiting for Rapier3D to fix\n\nvar createJointApi = function createJointApi(ref) {\n  return {\n    raw: function raw() {\n      return ref.current();\n    },\n    get handle() {\n      return ref.current().handle;\n    },\n    configureMotorPosition: function configureMotorPosition(targetPos, stiffness, damping) {\n      return ref.current().configureMotorPosition(targetPos, stiffness, damping);\n    },\n    configureMotorVelocity: function configureMotorVelocity(targetVel, damping) {\n      return ref.current().configureMotorVelocity(targetVel, damping);\n    }\n  };\n};\nvar RapierContext = /*#__PURE__*/createContext(undefined);\nvar importRapier = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var r;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return import('@dimforge/rapier3d-compat');\n          case 2:\n            r = _context.sent;\n            _context.next = 5;\n            return r.init();\n          case 5:\n            return _context.abrupt(\"return\", r);\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return function importRapier() {\n    return _ref4.apply(this, arguments);\n  };\n}();\nvar Physics = function Physics(_ref5) {\n  var _ref5$colliders = _ref5.colliders,\n    _colliders = _ref5$colliders === void 0 ? \"cuboid\" : _ref5$colliders,\n    _ref5$gravity = _ref5.gravity,\n    _gravity = _ref5$gravity === void 0 ? [0, -9.81, 0] : _ref5$gravity,\n    children = _ref5.children,\n    _ref5$timeStep = _ref5.timeStep,\n    _timeStep = _ref5$timeStep === void 0 ? 1 / 60 : _ref5$timeStep,\n    _ref5$paused = _ref5.paused,\n    _paused = _ref5$paused === void 0 ? false : _ref5$paused,\n    updatePriority = _ref5.updatePriority;\n  var rapier = useAsset(importRapier);\n  var worldRef = useRef();\n  var getWorldRef = useRef(function () {\n    if (!worldRef.current) {\n      var world = new rapier.World(vectorArrayToVector3(_gravity));\n      worldRef.current = world;\n    }\n    return worldRef.current;\n  });\n  var _useState = useState(function () {\n      return new Map();\n    }),\n    _useState2 = _slicedToArray(_useState, 1),\n    rigidBodyStates = _useState2[0];\n  var _useState3 = useState(function () {\n      return new Map();\n    }),\n    _useState4 = _slicedToArray(_useState3, 1),\n    colliderStates = _useState4[0];\n  var _useState5 = useState(function () {\n      return new Map();\n    }),\n    _useState6 = _slicedToArray(_useState5, 1),\n    rigidBodyEvents = _useState6[0];\n  var _useState7 = useState(function () {\n      return new Map();\n    }),\n    _useState8 = _slicedToArray(_useState7, 1),\n    colliderEvents = _useState8[0];\n  var _useState9 = useState(function () {\n      return new EventQueue(false);\n    }),\n    _useState10 = _slicedToArray(_useState9, 1),\n    eventQueue = _useState10[0]; // Init world\n\n  useEffect(function () {\n    var world = getWorldRef.current();\n    return function () {\n      if (world) {\n        world.free();\n        worldRef.current = undefined;\n      }\n    };\n  }, []); // Update gravity\n\n  useEffect(function () {\n    var world = worldRef.current;\n    if (world) {\n      world.gravity = vectorArrayToVector3(_gravity);\n    }\n  }, [_gravity]);\n  var _useState11 = useState({\n      accumulator: 0\n    }),\n    _useState12 = _slicedToArray(_useState11, 1),\n    steppingState = _useState12[0];\n  /* Check if the timestep is supposed to be variable. We'll do this here\n  once so we don't have to string-check every frame. */\n\n  var timeStepVariable = _timeStep === \"vary\";\n  useFrame(function (_, dt) {\n    var world = worldRef.current;\n    if (!world) return;\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    var clampedDelta = MathUtils.clamp(dt, 0, 0.2);\n    if (timeStepVariable) {\n      world.timestep = clampedDelta;\n      if (!_paused) world.step(eventQueue);\n    } else {\n      world.timestep = _timeStep; // don't step time forwards if paused\n      // Increase accumulator\n\n      steppingState.accumulator += _paused ? 0 : clampedDelta;\n      if (!_paused) {\n        while (steppingState.accumulator >= _timeStep) {\n          world.step(eventQueue);\n          steppingState.accumulator -= _timeStep;\n        }\n      }\n    }\n    var interpolationAlpha = timeStepVariable ? 1 : steppingState.accumulator % _timeStep / _timeStep; // Update meshes\n\n    rigidBodyStates.forEach(function (state, handle) {\n      var rigidBody = world.getRigidBody(handle);\n      var events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() || !state.setMatrix) {\n        return;\n      }\n      var t = rigidBody.translation();\n      var r = rigidBody.rotation(); // Get new position\n\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.object instanceof InstancedMesh) {\n        state.setMatrix(_matrix4);\n        state.object.instanceMatrix.needsUpdate = true;\n      } else {\n        // Interpolate from last position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents(function (handle1, handle2, started) {\n      var _collider1$parent, _collider2$parent;\n      var collider1 = world.getCollider(handle1);\n      var collider2 = world.getCollider(handle2);\n      var rigidBodyHandle1 = (_collider1$parent = collider1.parent()) === null || _collider1$parent === void 0 ? void 0 : _collider1$parent.handle;\n      var rigidBodyHandle2 = (_collider2$parent = collider2.parent()) === null || _collider2$parent === void 0 ? void 0 : _collider2$parent.handle; // Collision Events\n\n      if (!collider1 || !collider2) {\n        return;\n      }\n      var collider1Events = colliderEvents.get(collider1.handle);\n      var collider2Events = colliderEvents.get(collider2.handle);\n      var rigidBody1 = rigidBodyHandle1 ? world.getRigidBody(rigidBodyHandle1) : undefined;\n      var rigidBody2 = rigidBodyHandle2 ? world.getRigidBody(rigidBodyHandle2) : undefined;\n      var rigidBody1Events = rigidBodyHandle1 ? rigidBodyEvents.get(rigidBodyHandle1) : undefined;\n      var rigidBody2Events = rigidBodyHandle2 ? rigidBodyEvents.get(rigidBodyHandle2) : undefined;\n      var collider1State = colliderStates.get(collider1.handle);\n      var collider2State = colliderStates.get(collider2.handle);\n      var rigidBody1State = rigidBodyHandle1 ? rigidBodyStates.get(rigidBodyHandle1) : undefined;\n      var rigidBody2State = rigidBodyHandle2 ? rigidBodyStates.get(rigidBodyHandle2) : undefined;\n      if (started) {\n        world.contactPair(collider1, collider2, function (manifold, flipped) {\n          var _rigidBody1Events$onC, _rigidBody2Events$onC, _collider1Events$onCo, _collider2Events$onCo;\n\n          /* RigidBody events */\n          rigidBody1Events === null || rigidBody1Events === void 0 ? void 0 : (_rigidBody1Events$onC = rigidBody1Events.onCollisionEnter) === null || _rigidBody1Events$onC === void 0 ? void 0 : _rigidBody1Events$onC.call(rigidBody1Events, {\n            rigidBody: rigidBody2,\n            collider: collider2,\n            colliderObject: collider2State === null || collider2State === void 0 ? void 0 : collider2State.object,\n            rigidBodyObject: rigidBody2State === null || rigidBody2State === void 0 ? void 0 : rigidBody2State.object,\n            manifold: manifold,\n            flipped: flipped\n          });\n          rigidBody2Events === null || rigidBody2Events === void 0 ? void 0 : (_rigidBody2Events$onC = rigidBody2Events.onCollisionEnter) === null || _rigidBody2Events$onC === void 0 ? void 0 : _rigidBody2Events$onC.call(rigidBody2Events, {\n            rigidBody: rigidBody1,\n            collider: collider1,\n            colliderObject: collider1State === null || collider1State === void 0 ? void 0 : collider1State.object,\n            rigidBodyObject: rigidBody1State === null || rigidBody1State === void 0 ? void 0 : rigidBody1State.object,\n            manifold: manifold,\n            flipped: flipped\n          });\n          /* Collider events */\n\n          collider1Events === null || collider1Events === void 0 ? void 0 : (_collider1Events$onCo = collider1Events.onCollisionEnter) === null || _collider1Events$onCo === void 0 ? void 0 : _collider1Events$onCo.call(collider1Events, {\n            rigidBody: rigidBody2,\n            collider: collider2,\n            colliderObject: collider2State === null || collider2State === void 0 ? void 0 : collider2State.object,\n            rigidBodyObject: rigidBody2State === null || rigidBody2State === void 0 ? void 0 : rigidBody2State.object,\n            manifold: manifold,\n            flipped: flipped\n          });\n          collider2Events === null || collider2Events === void 0 ? void 0 : (_collider2Events$onCo = collider2Events.onCollisionEnter) === null || _collider2Events$onCo === void 0 ? void 0 : _collider2Events$onCo.call(collider2Events, {\n            rigidBody: rigidBody1,\n            collider: collider1,\n            colliderObject: collider1State === null || collider1State === void 0 ? void 0 : collider1State.object,\n            rigidBodyObject: rigidBody1State === null || rigidBody1State === void 0 ? void 0 : rigidBody1State.object,\n            manifold: manifold,\n            flipped: flipped\n          });\n        });\n      } else {\n        var _rigidBody1Events$onC2, _rigidBody2Events$onC2, _collider1Events$onCo2, _collider2Events$onCo2;\n        rigidBody1Events === null || rigidBody1Events === void 0 ? void 0 : (_rigidBody1Events$onC2 = rigidBody1Events.onCollisionExit) === null || _rigidBody1Events$onC2 === void 0 ? void 0 : _rigidBody1Events$onC2.call(rigidBody1Events, {\n          rigidBody: rigidBody2,\n          collider: collider2\n        });\n        rigidBody2Events === null || rigidBody2Events === void 0 ? void 0 : (_rigidBody2Events$onC2 = rigidBody2Events.onCollisionExit) === null || _rigidBody2Events$onC2 === void 0 ? void 0 : _rigidBody2Events$onC2.call(rigidBody2Events, {\n          rigidBody: rigidBody1,\n          collider: collider1\n        });\n        collider1Events === null || collider1Events === void 0 ? void 0 : (_collider1Events$onCo2 = collider1Events.onCollisionExit) === null || _collider1Events$onCo2 === void 0 ? void 0 : _collider1Events$onCo2.call(collider1Events, {\n          rigidBody: rigidBody2,\n          collider: collider2\n        });\n        collider2Events === null || collider2Events === void 0 ? void 0 : (_collider2Events$onCo2 = collider2Events.onCollisionExit) === null || _collider2Events$onCo2 === void 0 ? void 0 : _collider2Events$onCo2.call(collider2Events, {\n          rigidBody: rigidBody1,\n          collider: collider1\n        });\n      } // Sensor Intersections\n\n      if (started) {\n        if (world.intersectionPair(collider1, collider2)) {\n          var _rigidBody1Events$onI, _rigidBody2Events$onI, _collider1Events$onIn, _collider2Events$onIn;\n          rigidBody1Events === null || rigidBody1Events === void 0 ? void 0 : (_rigidBody1Events$onI = rigidBody1Events.onIntersectionEnter) === null || _rigidBody1Events$onI === void 0 ? void 0 : _rigidBody1Events$onI.call(rigidBody1Events, {\n            rigidBody: rigidBody2,\n            collider: collider2,\n            colliderObject: collider2State === null || collider2State === void 0 ? void 0 : collider2State.object,\n            rigidBodyObject: rigidBody2State === null || rigidBody2State === void 0 ? void 0 : rigidBody2State.object\n          });\n          rigidBody2Events === null || rigidBody2Events === void 0 ? void 0 : (_rigidBody2Events$onI = rigidBody2Events.onIntersectionEnter) === null || _rigidBody2Events$onI === void 0 ? void 0 : _rigidBody2Events$onI.call(rigidBody2Events, {\n            rigidBody: rigidBody1,\n            collider: collider1,\n            colliderObject: collider1State === null || collider1State === void 0 ? void 0 : collider1State.object,\n            rigidBodyObject: rigidBody1State === null || rigidBody1State === void 0 ? void 0 : rigidBody1State.object\n          });\n          collider1Events === null || collider1Events === void 0 ? void 0 : (_collider1Events$onIn = collider1Events.onIntersectionEnter) === null || _collider1Events$onIn === void 0 ? void 0 : _collider1Events$onIn.call(collider1Events, {\n            rigidBody: rigidBody2,\n            collider: collider2,\n            colliderObject: collider2State === null || collider2State === void 0 ? void 0 : collider2State.object,\n            rigidBodyObject: rigidBody2State === null || rigidBody2State === void 0 ? void 0 : rigidBody2State.object\n          });\n          collider2Events === null || collider2Events === void 0 ? void 0 : (_collider2Events$onIn = collider2Events.onIntersectionEnter) === null || _collider2Events$onIn === void 0 ? void 0 : _collider2Events$onIn.call(collider2Events, {\n            rigidBody: rigidBody1,\n            collider: collider1,\n            colliderObject: collider1State === null || collider1State === void 0 ? void 0 : collider1State.object,\n            rigidBodyObject: rigidBody1State === null || rigidBody1State === void 0 ? void 0 : rigidBody1State.object\n          });\n        }\n      } else {\n        var _rigidBody1Events$onI2, _rigidBody2Events$onI2, _collider1Events$onIn2, _collider2Events$onIn2;\n        rigidBody1Events === null || rigidBody1Events === void 0 ? void 0 : (_rigidBody1Events$onI2 = rigidBody1Events.onIntersectionExit) === null || _rigidBody1Events$onI2 === void 0 ? void 0 : _rigidBody1Events$onI2.call(rigidBody1Events, {\n          rigidBody: rigidBody2,\n          collider: collider2\n        });\n        rigidBody2Events === null || rigidBody2Events === void 0 ? void 0 : (_rigidBody2Events$onI2 = rigidBody2Events.onIntersectionExit) === null || _rigidBody2Events$onI2 === void 0 ? void 0 : _rigidBody2Events$onI2.call(rigidBody2Events, {\n          rigidBody: rigidBody1,\n          collider: collider1\n        });\n        collider1Events === null || collider1Events === void 0 ? void 0 : (_collider1Events$onIn2 = collider1Events.onIntersectionExit) === null || _collider1Events$onIn2 === void 0 ? void 0 : _collider1Events$onIn2.call(collider1Events, {\n          rigidBody: rigidBody2,\n          collider: collider2\n        });\n        collider2Events === null || collider2Events === void 0 ? void 0 : (_collider2Events$onIn2 = collider2Events.onIntersectionExit) === null || _collider2Events$onIn2 === void 0 ? void 0 : _collider2Events$onIn2.call(collider2Events, {\n          rigidBody: rigidBody1,\n          collider: collider1\n        });\n      }\n    });\n  }, updatePriority);\n  var api = useMemo(function () {\n    return createWorldApi(getWorldRef);\n  }, []);\n  var context = useMemo(function () {\n    return {\n      rapier: rapier,\n      world: api,\n      physicsOptions: {\n        colliders: _colliders,\n        gravity: _gravity\n      },\n      rigidBodyStates: rigidBodyStates,\n      colliderStates: colliderStates,\n      rigidBodyEvents: rigidBodyEvents,\n      colliderEvents: colliderEvents,\n      isPaused: _paused\n    };\n  }, [_paused]);\n  return /*#__PURE__*/React.createElement(RapierContext.Provider, {\n    value: context\n  }, children);\n};\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar rigidBodyDescFromOptions = function rigidBodyDescFromOptions(options) {\n  var type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  var desc = new RigidBodyDesc(type);\n  return desc;\n};\nvar createRigidBodyState = function createRigidBodyState(_ref6) {\n  var rigidBody = _ref6.rigidBody,\n    object = _ref6.object,\n    setMatrix = _ref6.setMatrix,\n    getMatrix = _ref6.getMatrix,\n    worldScale = _ref6.worldScale;\n  object.updateWorldMatrix(true, false);\n  var invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object: object,\n    rigidBody: rigidBody,\n    invertedWorldMatrix: invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : function (matrix) {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : function (matrix) {\n      return matrix.copy(object.matrix);\n    },\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false\n  };\n};\nvar mutableRigidBodyOptions = {\n  gravityScale: function gravityScale(rb, value) {\n    rb.setGravityScale(value, true);\n  },\n  linearDamping: function linearDamping(rb, value) {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: function angularDamping(rb, value) {\n    rb.setAngularDamping(value);\n  },\n  enabledRotations: function enabledRotations(rb, _ref7) {\n    var _ref8 = _slicedToArray(_ref7, 3),\n      x = _ref8[0],\n      y = _ref8[1],\n      z = _ref8[2];\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: function enabledTranslations(rb, _ref9) {\n    var _ref10 = _slicedToArray(_ref9, 3),\n      x = _ref10[0],\n      y = _ref10[1],\n      z = _ref10[2];\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  angularVelocity: function angularVelocity(rb, _ref11) {\n    var _ref12 = _slicedToArray(_ref11, 3),\n      x = _ref12[0],\n      y = _ref12[1],\n      z = _ref12[2];\n    rb.setAngvel({\n      x: x,\n      y: y,\n      z: z\n    }, true);\n  },\n  linearVelocity: function linearVelocity(rb, _ref13) {\n    var _ref14 = _slicedToArray(_ref13, 3),\n      x = _ref14[0],\n      y = _ref14[1],\n      z = _ref14[2];\n    rb.setLinvel({\n      x: x,\n      y: y,\n      z: z\n    }, true);\n  },\n  ccd: function ccd(rb, value) {\n    rb.enableCcd(value);\n  },\n  position: function position() {},\n  rotation: function rotation() {},\n  quaternion: function quaternion() {},\n  scale: function scale() {}\n};\nvar mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nvar setRigidBodyOptions = function setRigidBodyOptions(rigidBody, options, states) {\n  var updateTranslations = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (!rigidBody) {\n    return;\n  }\n  var state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(function (key) {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nvar useUpdateRigidBodyOptions = function useUpdateRigidBodyOptions(rigidBodyRef, props, states) {\n  var updateTranslations = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  // TODO: Improve this, split each prop into its own effect\n  var mutablePropsAsFlatArray = useMemo(function () {\n    return mutableRigidBodyOptionKeys.flatMap(function (key) {\n      return vectorToTuple(props[key]);\n    });\n  }, [props]);\n  useEffect(function () {\n    if (Array.isArray(rigidBodyRef.current)) {\n      var _iterator = _createForOfIteratorHelper(rigidBodyRef.current),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var rigidBody = _step.value;\n          setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } else if (rigidBodyRef.current) {\n      setRigidBodyOptions(rigidBodyRef.current, props, states, updateTranslations);\n    }\n  }, mutablePropsAsFlatArray);\n};\nvar useRigidBodyEvents = function useRigidBodyEvents(rigidBodyRef, props, events) {\n  var onWake = props.onWake,\n    onSleep = props.onSleep,\n    onCollisionEnter = props.onCollisionEnter,\n    onCollisionExit = props.onCollisionExit,\n    onIntersectionEnter = props.onIntersectionEnter,\n    onIntersectionExit = props.onIntersectionExit;\n  var eventHandlers = {\n    onWake: onWake,\n    onSleep: onSleep,\n    onCollisionEnter: onCollisionEnter,\n    onCollisionExit: onCollisionExit,\n    onIntersectionEnter: onIntersectionEnter,\n    onIntersectionExit: onIntersectionExit\n  };\n  useEffect(function () {\n    if (Array.isArray(rigidBodyRef.current)) {\n      var _iterator2 = _createForOfIteratorHelper(rigidBodyRef.current),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var rigidBody = _step2.value;\n          events.set(rigidBody.handle, eventHandlers);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else if (rigidBodyRef.current) {\n      events.set(rigidBodyRef.current.handle, eventHandlers);\n    }\n    return function () {\n      if (Array.isArray(rigidBodyRef.current)) {\n        var _iterator3 = _createForOfIteratorHelper(rigidBodyRef.current),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _rigidBody = _step3.value;\n            events.delete(_rigidBody.handle);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      } else if (rigidBodyRef.current) {\n        events.delete(rigidBodyRef.current.handle);\n      }\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit]);\n};\nvar scaleColliderArgs = function scaleColliderArgs(shape, args, scale) {\n  var newArgs = args.slice(); // Heightfield uses a vector\n\n  if (shape === \"heightfield\") {\n    var s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  } // Trimesh and convex scale the vertices\n\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  } // Prepfill with some extra\n\n  var scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map(function (arg, index) {\n    return scaleArray[index] * arg;\n  });\n};\nvar createColliderFromOptions = function createColliderFromOptions(options, world, scale, rigidBody) {\n  var scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore\n\n  var desc = ColliderDesc[options.shape].apply(ColliderDesc, _toConsumableArray(scaledArgs));\n  return world.createCollider(desc, rigidBody);\n};\nvar massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nvar setColliderMassOptions = function setColliderMassOptions(collider, options) {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nvar mutableColliderOptions = {\n  sensor: function sensor(collider, value) {\n    collider.setSensor(value);\n  },\n  collisionGroups: function collisionGroups(collider, value) {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: function solverGroups(collider, value) {\n    collider.setSolverGroups(value);\n  },\n  friction: function friction(collider, value) {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: function frictionCombineRule(collider, value) {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: function restitution(collider, value) {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: function restitutionCombineRule(collider, value) {\n    collider.setRestitutionCombineRule(value);\n  },\n  // To make sure the options all mutalbe options are listed\n  quaternion: function quaternion() {},\n  position: function position() {},\n  rotation: function rotation() {},\n  scale: function scale() {}\n};\nvar mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nvar setColliderOptions = function setColliderOptions(collider, options, states) {\n  var state = states.get(collider.handle);\n  if (state) {\n    // Update collider position based on the object's position\n    var parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld).premultiply(state.worldParent.matrixWorld.clone().invert()).decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(function (key) {\n      if (key in options) {\n        var option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    }); // handle mass separately, because the assignments\n    // are exclusive.\n\n    setColliderMassOptions(collider, options);\n  }\n};\nvar useUpdateColliderOptions = function useUpdateColliderOptions(collidersRef, props, states) {\n  // TODO: Improve this, split each prop into its own effect\n  var mutablePropsAsFlatArray = useMemo(function () {\n    return mutableColliderOptionKeys.flatMap(function (key) {\n      return vectorToTuple(props[key]);\n    });\n  }, [props]);\n  useEffect(function () {\n    collidersRef.current.forEach(function (collider) {\n      setColliderOptions(collider, props, states);\n    });\n  }, mutablePropsAsFlatArray);\n};\nvar isChildOfMeshCollider = function isChildOfMeshCollider(child) {\n  var flag = false;\n  child.traverseAncestors(function (a) {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nvar createColliderState = function createColliderState(collider, object, rigidBodyObject) {\n  return {\n    collider: collider,\n    worldParent: rigidBodyObject || object.parent,\n    object: object\n  };\n};\nvar autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nvar createColliderPropsFromChildren = function createColliderPropsFromChildren(_ref15) {\n  var object = _ref15.object,\n    _ref15$ignoreMeshColl = _ref15.ignoreMeshColliders,\n    _ignoreMeshColliders = _ref15$ignoreMeshColl === void 0 ? true : _ref15$ignoreMeshColl,\n    options = _ref15.options;\n  var colliderProps = [];\n  object.updateWorldMatrix(true, false);\n  var invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  object.traverseVisible(function (child) {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      var worldScale = child.getWorldScale(_scale);\n      var shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      var rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      var geometry = child.geometry;\n      var _getColliderArgsFromG = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\"),\n        args = _getColliderArgsFromG.args,\n        offset = _getColliderArgsFromG.offset;\n      colliderProps.push(_objectSpread2(_objectSpread2({}, options), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      }));\n    }\n  });\n  return colliderProps;\n};\nvar getColliderArgsFromGeometry = function getColliderArgsFromGeometry(geometry, colliders) {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        var boundingBox = geometry.boundingBox;\n        var size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        var boundingSphere = geometry.boundingSphere;\n        var radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        var clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        var g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nvar useColliderEvents = function useColliderEvents(collidersRef, props, events) {\n  var onCollisionEnter = props.onCollisionEnter,\n    onCollisionExit = props.onCollisionExit,\n    onIntersectionEnter = props.onIntersectionEnter,\n    onIntersectionExit = props.onIntersectionExit;\n  useEffect(function () {\n    var _collidersRef$current;\n    (_collidersRef$current = collidersRef.current) === null || _collidersRef$current === void 0 ? void 0 : _collidersRef$current.forEach(function (collider) {\n      if (onCollisionEnter || onCollisionExit || onIntersectionEnter || onIntersectionExit) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter: onCollisionEnter,\n        onCollisionExit: onCollisionExit,\n        onIntersectionEnter: onIntersectionEnter,\n        onIntersectionExit: onIntersectionExit\n      });\n    });\n    return function () {\n      var _collidersRef$current2;\n      (_collidersRef$current2 = collidersRef.current) === null || _collidersRef$current2 === void 0 ? void 0 : _collidersRef$current2.forEach(function (collider) {\n        return events.delete(collider.handle);\n      });\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit]);\n};\nvar useRapier = function useRapier() {\n  return useContext(RapierContext);\n};\nvar useChildColliderProps = function useChildColliderProps(ref, options) {\n  var ignoreMeshColliders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var _useState13 = useState([]),\n    _useState14 = _slicedToArray(_useState13, 2),\n    colliderProps = _useState14[0],\n    setColliderProps = _useState14[1];\n  useEffect(function () {\n    var object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options: options,\n        ignoreMeshColliders: ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\nvar useRigidBody = function useRigidBody() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _useRapier = useRapier(),\n    world = _useRapier.world,\n    rigidBodyStates = _useRapier.rigidBodyStates,\n    physicsOptions = _useRapier.physicsOptions,\n    rigidBodyEvents = _useRapier.rigidBodyEvents;\n  var ref = useRef();\n  var mergedOptions = useMemo(function () {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, options]);\n  var childColliderProps = useChildColliderProps(ref, mergedOptions); // Create rigidbody\n\n  var rigidBodyRef = useRef();\n  var getRigidBodyRef = useRef(function () {\n    if (!rigidBodyRef.current) {\n      var desc = rigidBodyDescFromOptions(options);\n      var rigidBody = world.createRigidBody(desc);\n      rigidBodyRef.current = world.getRigidBody(rigidBody.handle);\n    }\n    return rigidBodyRef.current;\n  }); // Setup\n\n  useEffect(function () {\n    var rigidBody = getRigidBodyRef.current();\n    rigidBodyRef.current = rigidBody;\n    if (!ref.current) {\n      ref.current = new Object3D();\n    } // isSleeping used for onSleep and onWake events\n\n    ref.current.userData.isSleeping = false;\n    rigidBodyStates.set(rigidBody.handle, createRigidBodyState({\n      rigidBody: rigidBody,\n      object: ref.current\n    }));\n    return function () {\n      world.removeRigidBody(rigidBody);\n      rigidBodyStates.delete(rigidBody.handle);\n      rigidBodyRef.current = undefined;\n    };\n  }, []);\n  useUpdateRigidBodyOptions(rigidBodyRef, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(rigidBodyRef, mergedOptions, rigidBodyEvents);\n  var api = useMemo(function () {\n    return createRigidBodyApi(getRigidBodyRef);\n  }, []);\n  return [ref, api, childColliderProps];\n}; // Joints\n\nvar useImpulseJoint = function useImpulseJoint(body1, body2, params) {\n  var _useRapier2 = useRapier(),\n    world = _useRapier2.world;\n  var jointRef = useRef();\n  var getJointRef = useRef(function () {\n    if (!jointRef.current) {\n      var rb1;\n      var rb2;\n      if (\"current\" in body1 && body1.current && \"current\" in body2 && body2.current) {\n        rb1 = world.getRigidBody(body1.current.handle);\n        rb2 = world.getRigidBody(body2.current.handle);\n        var newJoint = world.createImpulseJoint(params, rb1, rb2);\n        jointRef.current = newJoint;\n      }\n    }\n    return jointRef.current;\n  });\n  useEffect(function () {\n    var joint = getJointRef.current();\n    return function () {\n      if (joint) {\n        world.removeImpulseJoint(joint);\n        jointRef.current = undefined;\n      }\n    };\n  }, []);\n  var api = useMemo(function () {\n    return createJointApi(getJointRef);\n  }, []);\n  return api;\n};\n/**\n *\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n */\n\nvar useFixedJoint = function useFixedJoint(body1, body2, _ref16) {\n  var _ref17 = _slicedToArray(_ref16, 4),\n    body1Anchor = _ref17[0],\n    body1LocalFrame = _ref17[1],\n    body2Anchor = _ref17[2],\n    body2LocalFrame = _ref17[3];\n  var _useRapier3 = useRapier(),\n    rapier = _useRapier3.rapier;\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vectorArrayToVector3(body1Anchor), _objectSpread2(_objectSpread2({}, vectorArrayToVector3(body1LocalFrame)), {}, {\n    w: 1\n  }), vectorArrayToVector3(body2Anchor), _objectSpread2(_objectSpread2({}, vectorArrayToVector3(body2LocalFrame)), {}, {\n    w: 1\n  })));\n};\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n */\n\nvar useSphericalJoint = function useSphericalJoint(body1, body2, _ref18) {\n  var _ref19 = _slicedToArray(_ref18, 2),\n    body1Anchor = _ref19[0],\n    body2Anchor = _ref19[1];\n  var _useRapier4 = useRapier(),\n    rapier = _useRapier4.rapier;\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor)));\n};\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n */\n\nvar useRevoluteJoint = function useRevoluteJoint(body1, body2, _ref20) {\n  var _ref21 = _slicedToArray(_ref20, 3),\n    body1Anchor = _ref21[0],\n    body2Anchor = _ref21[1],\n    axis = _ref21[2];\n  var _useRapier5 = useRapier(),\n    rapier = _useRapier5.rapier;\n  return useImpulseJoint(body1, body2, rapier.JointData.revolute(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis)));\n};\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n */\n\nvar usePrismaticJoint = function usePrismaticJoint(body1, body2, _ref22) {\n  var _ref23 = _slicedToArray(_ref22, 3),\n    body1Anchor = _ref23[0],\n    body2Anchor = _ref23[1],\n    axis = _ref23[2];\n  var _useRapier6 = useRapier(),\n    rapier = _useRapier6.rapier;\n  return useImpulseJoint(body1, body2, rapier.JointData.prismatic(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis)));\n};\n\n// Colliders\nvar AnyCollider = /*#__PURE__*/memo( /*#__PURE__*/React.forwardRef(function (props, forwardedRef) {\n  var children = props.children,\n    position = props.position,\n    rotation = props.rotation,\n    quaternion = props.quaternion,\n    scale = props.scale;\n  var _useRapier7 = useRapier(),\n    world = _useRapier7.world,\n    colliderEvents = _useRapier7.colliderEvents,\n    colliderStates = _useRapier7.colliderStates;\n  var rigidBodyContext = useRigidBodyContext();\n  var ref = useRef(null);\n  var collidersRef = useMemo(function () {\n    if (forwardedRef !== null) {\n      return forwardedRef;\n    }\n    var result = /*#__PURE__*/React.createRef();\n    result.current = [];\n    return result;\n  }, []);\n  useEffect(function () {\n    var object = ref.current;\n    var worldScale = object.getWorldScale(new Vector3());\n    var colliders = []; // If this is an InstancedRigidBody api\n\n    if (rigidBodyContext && \"at\" in rigidBodyContext.api) {\n      rigidBodyContext.api.forEach(function (body, index) {\n        var _rigidBodyContext$opt, _rigidBodyContext$opt2;\n        var instanceScale = worldScale;\n        if (\"scales\" in rigidBodyContext.options && rigidBodyContext !== null && rigidBodyContext !== void 0 && (_rigidBodyContext$opt = rigidBodyContext.options) !== null && _rigidBodyContext$opt !== void 0 && (_rigidBodyContext$opt2 = _rigidBodyContext$opt.scales) !== null && _rigidBodyContext$opt2 !== void 0 && _rigidBodyContext$opt2[index]) {\n          instanceScale = instanceScale.clone().multiply(vectorArrayToVector3(rigidBodyContext.options.scales[index]));\n        }\n        var collider = createColliderFromOptions(props, world, instanceScale, body.raw());\n        colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n        colliders.push(collider);\n      });\n    } else {\n      var collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext && (rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.api).raw());\n      colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n      colliders.push(collider);\n    }\n    collidersRef.current = colliders;\n    return function () {\n      colliders.forEach(function (collider) {\n        world.removeCollider(collider);\n      });\n    };\n  }, []);\n  var mergedProps = useMemo(function () {\n    return _objectSpread2(_objectSpread2({}, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(collidersRef, mergedProps, colliderStates);\n  useColliderEvents(collidersRef, mergedProps, colliderEvents);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: ref\n  }, children);\n}));\nvar CuboidCollider = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nvar RoundCuboidCollider = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"roundCuboid\",\n    ref: ref\n  }));\n});\nvar BallCollider = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"ball\",\n    ref: ref\n  }));\n});\nvar CapsuleCollider = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"capsule\",\n    ref: ref\n  }));\n});\nvar HeightfieldCollider = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"heightfield\",\n    ref: ref\n  }));\n});\nvar TrimeshCollider = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"trimesh\",\n    ref: ref\n  }));\n});\nvar ConeCollider = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cone\",\n    ref: ref\n  }));\n});\nvar CylinderCollider = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cylinder\",\n    ref: ref\n  }));\n});\nvar ConvexHullCollider = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"convexHull\",\n    ref: ref\n  }));\n});\nvar _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\"];\nvar RigidBodyContext = /*#__PURE__*/createContext(undefined);\nvar useRigidBodyContext = function useRigidBodyContext() {\n  return useContext(RigidBodyContext);\n};\nvar RigidBody = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function (props, ref) {\n  var children = props.children,\n    type = props.type,\n    position = props.position,\n    rotation = props.rotation,\n    scale = props.scale,\n    quaternion = props.quaternion,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  var _useRigidBody = useRigidBody(props),\n    _useRigidBody2 = _slicedToArray(_useRigidBody, 3),\n    object = _useRigidBody2[0],\n    api = _useRigidBody2[1],\n    childColliderProps = _useRigidBody2[2];\n  useImperativeHandle(ref, function () {\n    return api;\n  });\n  var contextValue = useMemo(function () {\n    return {\n      ref: object,\n      api: api,\n      options: props\n    };\n  }, [object, api, props]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: object\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map(function (colliderProps, index) {\n    return /*#__PURE__*/React.createElement(AnyCollider, _extends({\n      key: index\n    }, colliderProps));\n  })));\n}));\nvar MeshCollider = function MeshCollider(props) {\n  var children = props.children,\n    type = props.type;\n  var _useRapier8 = useRapier(),\n    physicsOptions = _useRapier8.physicsOptions,\n    world = _useRapier8.world;\n  var object = useRef(null);\n  var _useRigidBodyContext = useRigidBodyContext(),\n    options = _useRigidBodyContext.options;\n  var mergedOptions = useMemo(function () {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  var childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map(function (colliderProps, index) {\n    return /*#__PURE__*/React.createElement(AnyCollider, _extends({\n      key: index\n    }, colliderProps));\n  }));\n};\nvar geometryFromCollider = function geometryFromCollider(collider) {\n  switch (collider.shape.type) {\n    case ShapeType.Cuboid:\n      {\n        var _collider$shape$halfE = collider.shape.halfExtents,\n          x = _collider$shape$halfE.x,\n          y = _collider$shape$halfE.y,\n          z = _collider$shape$halfE.z;\n        return new BoxGeometry(x * 2 + 0.01, y * 2 + 0.01, z * 2 + 0.01);\n      }\n    case ShapeType.RoundCuboid:\n      {\n        var _collider$shape$halfE2 = collider.shape.halfExtents,\n          _x = _collider$shape$halfE2.x,\n          _y = _collider$shape$halfE2.y,\n          _z = _collider$shape$halfE2.z;\n        var radius = collider.shape.borderRadius;\n        return new RoundedBoxGeometry(_x * 2 + radius * 2, _y * 2 + radius * 2, _z * 2 + radius * 2, 8, radius);\n      }\n    case ShapeType.Ball:\n      {\n        var r = collider.shape.radius;\n        return new SphereGeometry(r + +0.01, 8, 8);\n      }\n    case ShapeType.TriMesh:\n      {\n        var _g$index;\n        var v = collider.shape.vertices;\n        var i = collider.shape.indices;\n        var g = new BufferGeometry(); // Vertices are not always a float3darray (???), so we need to convert them\n\n        var safeVerts = Float32Array.from(v);\n        g.setAttribute(\"position\", new BufferAttribute(safeVerts, 3));\n        (_g$index = g.index) === null || _g$index === void 0 ? void 0 : _g$index.set(i);\n        g.setDrawRange(0, g.attributes.position.array.length / 3 - 1);\n        return g;\n      }\n    case ShapeType.ConvexPolyhedron:\n      {\n        var cv = collider.shape.vertices; // Vertices are not always a float3darray (???), so we need to convert them\n\n        var _safeVerts = Float32Array.from(cv);\n        var cg = new BufferGeometry();\n        cg.setAttribute(\"position\", new BufferAttribute(_safeVerts, 3));\n        return cg;\n      }\n    case ShapeType.Cylinder:\n      {\n        var _r = collider.shape.radius;\n        var h = collider.shape.halfHeight;\n        var _g = new CylinderGeometry(_r, _r, h * 2);\n        return _g;\n      }\n    case ShapeType.Capsule:\n      {\n        var _r2 = collider.shape.radius;\n        var _h = collider.shape.halfHeight;\n        var _g2 = new CapsuleGeometry(_r2, _h * 2, 4, 8);\n        return _g2;\n      }\n    case ShapeType.Cone:\n      {\n        var _r3 = collider.shape.radius;\n        var _h2 = collider.shape.halfHeight;\n        var _g3 = new ConeGeometry(_r3, _h2 * 2, 16);\n        return _g3;\n      }\n    case ShapeType.HeightField:\n      {\n        var rows = collider.shape.nrows;\n        var cols = collider.shape.ncols;\n        var heights = collider.shape.heights;\n        var scale = collider.shape.scale;\n        var _g4 = new PlaneGeometry(scale.x, scale.z, cols, rows);\n        var verts = _g4.attributes.position.array;\n        verts.forEach(function (v, index) {\n          return verts[index * 3 + 2] = heights[index] * scale.y;\n        });\n        _g4.scale(1, -1, 1);\n        _g4.rotateX(-Math.PI / 2);\n        _g4.rotateY(-Math.PI / 2);\n        return _g4;\n      }\n  }\n  return new BoxGeometry(1, 1, 1);\n};\nvar DebugShape = /*#__PURE__*/memo(function (_ref24) {\n  var colliderHandle = _ref24.colliderHandle,\n    color = _ref24.color,\n    sleepColor = _ref24.sleepColor;\n  var _useRapier9 = useRapier(),\n    world = _useRapier9.world;\n  var ref = useRef(null);\n  var _useState15 = useState(new MeshBasicMaterial({\n      color: color,\n      wireframe: true\n    })),\n    _useState16 = _slicedToArray(_useState15, 1),\n    material = _useState16[0];\n  useFrame(function () {\n    var collider = world.getCollider(colliderHandle);\n    if (ref.current && collider) {\n      var _collider$rotation = collider.rotation(),\n        rx = _collider$rotation.x,\n        ry = _collider$rotation.y,\n        rz = _collider$rotation.z,\n        rw = _collider$rotation.w;\n      var _collider$translation = collider.translation(),\n        x = _collider$translation.x,\n        y = _collider$translation.y,\n        z = _collider$translation.z;\n      var parent = collider.parent();\n      if (parent !== null && parent !== void 0 && parent.isSleeping() || parent !== null && parent !== void 0 && parent.isFixed() || parent !== null && parent !== void 0 && parent.isKinematic()) {\n        material.color = new Color(sleepColor);\n      } else {\n        material.color = new Color(color);\n      }\n      ref.current.position.set(x, y, z);\n      ref.current.rotation.setFromQuaternion(new Quaternion(rx, ry, rz, rw));\n    }\n  });\n  var geometry = useMemo(function () {\n    var collider = world.getCollider(colliderHandle);\n    return geometryFromCollider(collider);\n  }, [colliderHandle]);\n  return /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: ref,\n    material: material\n  }, /*#__PURE__*/React.createElement(\"primitive\", {\n    object: geometry,\n    attach: \"geometry\"\n  }));\n});\nvar Debug = function Debug(_ref25) {\n  var _ref25$color = _ref25.color,\n    _color = _ref25$color === void 0 ? \"red\" : _ref25$color,\n    _ref25$sleepColor = _ref25.sleepColor,\n    _sleepColor = _ref25$sleepColor === void 0 ? \"blue\" : _ref25$sleepColor;\n  var _useRapier10 = useRapier(),\n    world = _useRapier10.world;\n  var _useState17 = useState([]),\n    _useState18 = _slicedToArray(_useState17, 2),\n    colliders = _useState18[0],\n    setColliders = _useState18[1];\n  useRef({});\n  useFrame(function () {\n    var newColliders = [];\n    world.forEachCollider(function (collider) {\n      newColliders.push(collider.handle);\n    });\n    setColliders(newColliders);\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, colliders.map(function (handle) {\n    return /*#__PURE__*/React.createElement(DebugShape, {\n      key: handle,\n      colliderHandle: handle,\n      color: _color,\n      sleepColor: _sleepColor\n    });\n  }));\n};\nvar _excluded = [\"positions\", \"rotations\", \"children\"];\nvar InstancedRigidBodies = /*#__PURE__*/forwardRef(function (props, ref) {\n  var _useRapier11 = useRapier(),\n    world = _useRapier11.world,\n    rigidBodyStates = _useRapier11.rigidBodyStates,\n    physicsOptions = _useRapier11.physicsOptions,\n    rigidBodyEvents = _useRapier11.rigidBodyEvents;\n  var object = useRef(null);\n  var positions = props.positions,\n    rotations = props.rotations,\n    children = props.children,\n    options = _objectWithoutProperties(props, _excluded);\n  var instancesRef = useRef([]);\n  var rigidBodyRefs = useRef([]);\n  var instancesRefGetter = useRef(function () {\n    if (!instancesRef.current) {\n      instancesRef.current = [];\n    }\n    return instancesRef.current;\n  });\n  var mergedOptions = useMemo(function () {\n    return _objectSpread2(_objectSpread2({}, physicsOptions), options);\n  }, [physicsOptions, options]);\n  var childColliderProps = useChildColliderProps(object, mergedOptions);\n  useLayoutEffect(function () {\n    object.current.updateWorldMatrix(true, false);\n    var instances = instancesRefGetter.current();\n    var invertedWorld = object.current.matrixWorld.clone().invert();\n    object.current.traverseVisible(function (mesh) {\n      if (mesh instanceof InstancedMesh) {\n        mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n        var worldScale = mesh.getWorldScale(_scale);\n        var _loop = function _loop(index) {\n          var desc = rigidBodyDescFromOptions(props);\n          var rigidBody = world.createRigidBody(desc);\n          rigidBodyRefs.current.push(rigidBody);\n          var scale = ((_options$scales = options.scales) === null || _options$scales === void 0 ? void 0 : _options$scales[index]) || [1, 1, 1];\n          var instanceScale = worldScale.clone().multiply(vectorArrayToVector3(scale));\n          rigidBodyStates.set(rigidBody.handle, createRigidBodyState({\n            rigidBody: rigidBody,\n            object: mesh,\n            setMatrix: function setMatrix(matrix) {\n              return mesh.setMatrixAt(index, matrix);\n            },\n            getMatrix: function getMatrix(matrix) {\n              mesh.getMatrixAt(index, matrix);\n              return matrix;\n            },\n            worldScale: instanceScale\n          }));\n          var _ref26 = (positions === null || positions === void 0 ? void 0 : positions[index]) || [0, 0, 0],\n            _ref27 = _slicedToArray(_ref26, 3),\n            x = _ref27[0],\n            y = _ref27[1],\n            z = _ref27[2];\n          var _ref28 = (rotations === null || rotations === void 0 ? void 0 : rotations[index]) || [0, 0, 0],\n            _ref29 = _slicedToArray(_ref28, 3),\n            rx = _ref29[0],\n            ry = _ref29[1],\n            rz = _ref29[2];\n          _object3d.position.set(x, y, z);\n          _object3d.rotation.set(rx, ry, rz);\n          _object3d.applyMatrix4(invertedWorld);\n          mesh.setMatrixAt(index, _object3d.matrix);\n          rigidBody.setTranslation(_object3d.position, false);\n          rigidBody.setRotation(_object3d.quaternion, false);\n          var api = createRigidBodyApi({\n            current: function current() {\n              return rigidBody;\n            }\n          });\n          instances.push({\n            rigidBody: rigidBody,\n            api: api\n          });\n        };\n        for (var index = 0; index < mesh.count; index++) {\n          var _options$scales;\n          _loop(index);\n        }\n      }\n    });\n    return function () {\n      instances.forEach(function (rb) {\n        world.removeRigidBody(rb.rigidBody);\n        rigidBodyStates.delete(rb.rigidBody.handle);\n      });\n      rigidBodyRefs.current = [];\n      instancesRef.current = [];\n    };\n  }, []);\n  var api = useMemo(function () {\n    return createInstancedRigidBodiesApi(instancesRefGetter);\n  }, []);\n  useImperativeHandle(ref, function () {\n    return api;\n  });\n  useUpdateRigidBodyOptions(rigidBodyRefs, mergedOptions, rigidBodyStates, false);\n  useRigidBodyEvents(rigidBodyRefs, mergedOptions, rigidBodyEvents);\n  var contextValue = useMemo(function () {\n    return {\n      ref: object,\n      api: api,\n      options: mergedOptions\n    };\n  }, [api, mergedOptions]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object\n  }, props.children, childColliderProps.map(function (colliderProps, index) {\n    return /*#__PURE__*/React.createElement(AnyCollider, _extends({\n      key: index\n    }, colliderProps));\n  })));\n});\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nvar interactionGroups = function interactionGroups(memberships, filters) {\n  return (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 65535);\n};\nvar bitmask = function bitmask(groups) {\n  return [groups].flat().reduce(function (acc, layer) {\n    return acc | 1 << layer;\n  }, 0);\n};\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, Debug, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundCuboidCollider, TrimeshCollider, interactionGroups, useChildColliderProps, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRigidBody, useSphericalJoint };","map":{"version":3,"names":["EventQueue","RigidBodyDesc","ColliderDesc","ActiveEvents","ShapeType","CoefficientCombineRule","Collider","RapierCollider","RigidBody","RapierRigidBody","React","useRef","useState","useEffect","useMemo","createContext","useContext","memo","forwardRef","useImperativeHandle","useLayoutEffect","useAsset","useFrame","Quaternion","Euler","Vector3","Object3D","Matrix4","MathUtils","InstancedMesh","MeshBasicMaterial","Color","PlaneGeometry","ConeGeometry","CapsuleGeometry","CylinderGeometry","BufferGeometry","BufferAttribute","SphereGeometry","BoxGeometry","DynamicDrawUsage","mergeVertices","RoundedBoxGeometry","_quaternion","_vector3","_object3d","_matrix4","_position","_rotation","_scale","vectorArrayToVector3","arr","x","y","z","rapierVector3ToVector3","set","rapierQuaternionToQuaternion","w","rigidBodyTypeMap","fixed","dynamic","kinematicPosition","kinematicVelocity","rigidBodyTypeFromString","type","scaleVertices","vertices","scale","scaledVerts","Array","from","i","length","vectorToTuple","v","isArray","createRigidBodyApi","ref","raw","current","handle","mass","applyImpulse","impulseVector","wakeUp","applyTorqueImpulse","torqueVector","applyImpulseAtPoint","impulsePoint","addForce","force","addForceAtPoint","point","addTorque","torque","translation","setTranslation","rotation","setRotation","linvel","setLinvel","velocity","angvel","setAngvel","linearDamping","setLinearDamping","factor","angularDamping","setAngularDamping","setNextKinematicRotation","setNextKinematicTranslation","resetForces","resetTorques","lockRotations","locked","lockTranslations","setEnabledRotations","setEnabledTranslations","createInstancedRigidBodiesApi","bodiesGetter","at","index","api","forEach","callback","map","b","count","createWorldApi","getCollider","getRigidBody","createRigidBody","desc","createCollider","rigidBody","removeRigidBody","bodies","contains","removeCollider","collider","colliders","createImpulseJoint","params","rigidBodyA","rigidBodyB","removeImpulseJoint","joint","impulseJoints","forEachCollider","setGravity","gravity","createJointApi","configureMotorPosition","targetPos","stiffness","damping","configureMotorVelocity","targetVel","RapierContext","undefined","importRapier","r","init","Physics","_colliders","_gravity","children","timeStep","_timeStep","paused","_paused","updatePriority","rapier","worldRef","getWorldRef","world","World","Map","rigidBodyStates","colliderStates","rigidBodyEvents","colliderEvents","eventQueue","free","accumulator","steppingState","timeStepVariable","_","dt","clampedDelta","clamp","timestep","step","interpolationAlpha","state","events","get","onSleep","onWake","isSleeping","_events$onSleep","call","_events$onWake","setMatrix","t","compose","premultiply","invertedWorldMatrix","decompose","object","instanceMatrix","needsUpdate","position","lerp","quaternion","slerp","drainCollisionEvents","handle1","handle2","started","_collider1$parent","_collider2$parent","collider1","collider2","rigidBodyHandle1","parent","rigidBodyHandle2","collider1Events","collider2Events","rigidBody1","rigidBody2","rigidBody1Events","rigidBody2Events","collider1State","collider2State","rigidBody1State","rigidBody2State","contactPair","manifold","flipped","_rigidBody1Events$onC","_rigidBody2Events$onC","_collider1Events$onCo","_collider2Events$onCo","onCollisionEnter","colliderObject","rigidBodyObject","_rigidBody1Events$onC2","_rigidBody2Events$onC2","_collider1Events$onCo2","_collider2Events$onCo2","onCollisionExit","intersectionPair","_rigidBody1Events$onI","_rigidBody2Events$onI","_collider1Events$onIn","_collider2Events$onIn","onIntersectionEnter","_rigidBody1Events$onI2","_rigidBody2Events$onI2","_collider1Events$onIn2","_collider2Events$onIn2","onIntersectionExit","context","physicsOptions","isPaused","createElement","Provider","value","_extends","Object","assign","bind","target","arguments","source","key","prototype","hasOwnProperty","apply","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","_objectWithoutProperties","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","_defineProperty","obj","defineProperty","enumerable","configurable","writable","ownKeys","enumerableOnly","symbols","filter","sym","getOwnPropertyDescriptor","push","_objectSpread2","getOwnPropertyDescriptors","defineProperties","rigidBodyDescFromOptions","options","createRigidBodyState","getMatrix","worldScale","updateWorldMatrix","matrixWorld","clone","invert","matrix","copy","getWorldScale","mutableRigidBodyOptions","gravityScale","rb","setGravityScale","enabledRotations","enabledTranslations","angularVelocity","linearVelocity","ccd","enableCcd","mutableRigidBodyOptionKeys","setRigidBodyOptions","states","updateTranslations","useUpdateRigidBodyOptions","rigidBodyRef","props","mutablePropsAsFlatArray","flatMap","useRigidBodyEvents","eventHandlers","delete","scaleColliderArgs","shape","args","newArgs","slice","s","scaleArray","arg","createColliderFromOptions","scaledArgs","massPropertiesConflictError","setColliderMassOptions","density","massProperties","Error","setDensity","setMass","setMassProperties","centerOfMass","principalAngularInertia","angularInertiaLocalFrame","mutableColliderOptions","sensor","setSensor","collisionGroups","setCollisionGroups","solverGroups","setSolverGroups","friction","setFriction","frictionCombineRule","setFrictionCombineRule","restitution","setRestitution","restitutionCombineRule","setRestitutionCombineRule","mutableColliderOptionKeys","setColliderOptions","parentWorldScale","worldParent","setTranslationWrtParent","setRotationWrtParent","option","useUpdateColliderOptions","collidersRef","isChildOfMeshCollider","child","flag","traverseAncestors","a","userData","r3RapierType","createColliderState","autoColliderMap","cuboid","ball","hull","trimesh","createColliderPropsFromChildren","ignoreMeshColliders","_ignoreMeshColliders","colliderProps","invertedParentMatrixWorld","traverseVisible","rotationEuler","setFromQuaternion","geometry","getColliderArgsFromGeometry","offset","computeBoundingBox","boundingBox","size","getSize","getCenter","computeBoundingSphere","boundingSphere","radius","center","_clonedGeometry$index","clonedGeometry","attributes","array","g","useColliderEvents","_collidersRef$current","setActiveEvents","COLLISION_EVENTS","_collidersRef$current2","useRapier","useChildColliderProps","setColliderProps","useRigidBody","mergedOptions","childColliderProps","getRigidBodyRef","useImpulseJoint","body1","body2","jointRef","getJointRef","rb1","rb2","newJoint","useFixedJoint","body1Anchor","body1LocalFrame","body2Anchor","body2LocalFrame","JointData","useSphericalJoint","spherical","useRevoluteJoint","axis","revolute","usePrismaticJoint","prismatic","AnyCollider","forwardedRef","rigidBodyContext","useRigidBodyContext","result","createRef","body","_rigidBodyContext$opt","_rigidBodyContext$opt2","instanceScale","scales","multiply","mergedProps","CuboidCollider","RoundCuboidCollider","BallCollider","CapsuleCollider","HeightfieldCollider","TrimeshCollider","ConeCollider","CylinderCollider","ConvexHullCollider","_excluded$1","RigidBodyContext","objectProps","contextValue","MeshCollider","geometryFromCollider","Cuboid","halfExtents","RoundCuboid","borderRadius","Ball","TriMesh","_g$index","indices","safeVerts","Float32Array","setAttribute","setDrawRange","ConvexPolyhedron","cv","cg","Cylinder","h","halfHeight","Capsule","Cone","HeightField","rows","nrows","cols","ncols","heights","verts","rotateX","Math","PI","rotateY","DebugShape","colliderHandle","color","sleepColor","wireframe","material","rx","ry","rz","rw","isFixed","isKinematic","attach","Debug","_color","_sleepColor","setColliders","newColliders","_excluded","InstancedRigidBodies","positions","rotations","instancesRef","rigidBodyRefs","instancesRefGetter","instances","invertedWorld","mesh","setUsage","_options$scales","setMatrixAt","getMatrixAt","applyMatrix4","interactionGroups","memberships","filters","bitmask","groups","flat","reduce","acc","layer"],"sources":["/run/media/private/jack/Media/Projects/GoldenLeaf/LibraryR3F/node_modules/@react-three/rapier/dist/react-three-rapier.esm.js"],"sourcesContent":["import { EventQueue, RigidBodyDesc, ColliderDesc, ActiveEvents, ShapeType } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport React, { useRef, useState, useEffect, useMemo, createContext, useContext, memo, forwardRef, useImperativeHandle, useLayoutEffect } from 'react';\nimport { useAsset } from 'use-asset';\nimport { useFrame } from '@react-three/fiber';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, MathUtils, InstancedMesh, MeshBasicMaterial, Color, PlaneGeometry, ConeGeometry, CapsuleGeometry, CylinderGeometry, BufferGeometry, BufferAttribute, SphereGeometry, BoxGeometry, DynamicDrawUsage } from 'three';\nimport { mergeVertices, RoundedBoxGeometry } from 'three-stdlib';\n\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nconst _object3d = new Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierVector3ToVector3 = ({\n  x,\n  y,\n  z\n}) => _vector3.set(x, y, z);\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n\n  if (Array.isArray(v)) {\n    return v;\n  }\n\n  return [v];\n};\n\nconst createRigidBodyApi = ref => {\n  return {\n    raw: () => ref.current(),\n\n    get handle() {\n      return ref.current().handle;\n    },\n\n    mass: () => ref.current().mass(),\n\n    applyImpulse(impulseVector, wakeUp = true) {\n      ref.current().applyImpulse(impulseVector, wakeUp);\n    },\n\n    applyTorqueImpulse(torqueVector, wakeUp = true) {\n      ref.current().applyTorqueImpulse(torqueVector, wakeUp);\n    },\n\n    applyImpulseAtPoint: (impulseVector, impulsePoint, wakeUp = true) => ref.current().applyImpulseAtPoint(impulseVector, impulsePoint, wakeUp),\n    addForce: (force, wakeUp = true) => ref.current().addForce(force, wakeUp),\n    addForceAtPoint: (force, point, wakeUp = true) => ref.current().addForceAtPoint(force, point, wakeUp),\n    addTorque: (torque, wakeUp = true) => ref.current().addTorque(torque, wakeUp),\n\n    translation() {\n      return rapierVector3ToVector3(ref.current().translation());\n    },\n\n    setTranslation: (translation, wakeUp = true) => ref.current().setTranslation(translation, wakeUp),\n\n    rotation() {\n      const {\n        x,\n        y,\n        z,\n        w\n      } = ref.current().rotation();\n      return new Quaternion(x, y, z, w);\n    },\n\n    setRotation: (rotation, wakeUp = true) => {\n      ref.current().setRotation(rotation, wakeUp);\n    },\n\n    linvel() {\n      const {\n        x,\n        y,\n        z\n      } = ref.current().linvel();\n      return new Vector3(x, y, z);\n    },\n\n    setLinvel: (velocity, wakeUp = true) => ref.current().setLinvel(velocity, wakeUp),\n\n    angvel() {\n      const {\n        x,\n        y,\n        z\n      } = ref.current().angvel();\n      return new Vector3(x, y, z);\n    },\n\n    setAngvel: (velocity, wakeUp = true) => ref.current().setAngvel(velocity, wakeUp),\n\n    linearDamping() {\n      return ref.current().linearDamping();\n    },\n\n    setLinearDamping: factor => ref.current().setLinearDamping(factor),\n\n    angularDamping() {\n      return ref.current().angularDamping();\n    },\n\n    setAngularDamping: factor => ref.current().setAngularDamping(factor),\n    setNextKinematicRotation: rotation => {\n      ref.current().setNextKinematicRotation(rotation);\n    },\n    setNextKinematicTranslation: translation => ref.current().setNextKinematicTranslation(translation),\n    resetForces: (wakeUp = true) => ref.current().resetForces(wakeUp),\n    resetTorques: (wakeUp = true) => ref.current().resetTorques(wakeUp),\n    lockRotations: (locked, wakeUp = true) => ref.current().lockRotations(locked, wakeUp),\n    lockTranslations: (locked, wakeUp = true) => ref.current().lockTranslations(locked, wakeUp),\n    setEnabledRotations: (x, y, z, wakeUp = true) => ref.current().setEnabledRotations(x, y, z, wakeUp),\n    setEnabledTranslations: (x, y, z, wakeUp = true) => ref.current().setEnabledTranslations(x, y, z, wakeUp)\n  };\n};\nconst createInstancedRigidBodiesApi = bodiesGetter => ({\n  at: index => bodiesGetter.current()[index].api,\n\n  forEach(callback) {\n    return bodiesGetter.current().map(b => b.api).forEach(callback);\n  },\n\n  get count() {\n    return bodiesGetter.current().length;\n  }\n\n}); // TODO: Flesh this out\nconst createWorldApi = ref => {\n  return {\n    raw: () => ref.current(),\n    getCollider: handle => ref.current().getCollider(handle),\n    getRigidBody: handle => ref.current().getRigidBody(handle),\n    createRigidBody: desc => ref.current().createRigidBody(desc),\n    createCollider: (desc, rigidBody) => ref.current().createCollider(desc, rigidBody),\n    removeRigidBody: rigidBody => {\n      if (!ref.current().bodies.contains(rigidBody.handle)) return;\n      ref.current().removeRigidBody(rigidBody);\n    },\n    removeCollider: (collider, wakeUp = true) => {\n      if (!ref.current().colliders.contains(collider.handle)) return;\n      ref.current().removeCollider(collider, wakeUp);\n    },\n    createImpulseJoint: (params, rigidBodyA, rigidBodyB, wakeUp = true) => ref.current().createImpulseJoint(params, rigidBodyA, rigidBodyB, wakeUp),\n    removeImpulseJoint: (joint, wakeUp = true) => {\n      if (!ref.current().impulseJoints.contains(joint.handle)) return;\n      ref.current().removeImpulseJoint(joint, wakeUp);\n    },\n    forEachCollider: callback => ref.current().forEachCollider(callback),\n    setGravity: ({\n      x,\n      y,\n      z\n    }) => ref.current().gravity = {\n      x,\n      y,\n      z\n    }\n  };\n}; // TODO: Broken currently, waiting for Rapier3D to fix\n\nconst createJointApi = ref => {\n  return {\n    raw: () => ref.current(),\n\n    get handle() {\n      return ref.current().handle;\n    },\n\n    configureMotorPosition: (targetPos, stiffness, damping) => ref.current().configureMotorPosition(targetPos, stiffness, damping),\n    configureMotorVelocity: (targetVel, damping) => ref.current().configureMotorVelocity(targetVel, damping)\n  };\n};\n\nconst RapierContext = /*#__PURE__*/createContext(undefined);\n\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n\nconst Physics = ({\n  colliders: _colliders = \"cuboid\",\n  gravity: _gravity = [0, -9.81, 0],\n  children,\n  timeStep: _timeStep = 1 / 60,\n  paused: _paused = false,\n  updatePriority\n}) => {\n  const rapier = useAsset(importRapier);\n  const worldRef = useRef();\n  const getWorldRef = useRef(() => {\n    if (!worldRef.current) {\n      const world = new rapier.World(vectorArrayToVector3(_gravity));\n      worldRef.current = world;\n    }\n\n    return worldRef.current;\n  });\n  const [rigidBodyStates] = useState(() => new Map());\n  const [colliderStates] = useState(() => new Map());\n  const [rigidBodyEvents] = useState(() => new Map());\n  const [colliderEvents] = useState(() => new Map());\n  const [eventQueue] = useState(() => new EventQueue(false)); // Init world\n\n  useEffect(() => {\n    const world = getWorldRef.current();\n    return () => {\n      if (world) {\n        world.free();\n        worldRef.current = undefined;\n      }\n    };\n  }, []); // Update gravity\n\n  useEffect(() => {\n    const world = worldRef.current;\n\n    if (world) {\n      world.gravity = vectorArrayToVector3(_gravity);\n    }\n  }, [_gravity]);\n  const [steppingState] = useState({\n    accumulator: 0\n  });\n  /* Check if the timestep is supposed to be variable. We'll do this here\n  once so we don't have to string-check every frame. */\n\n  const timeStepVariable = _timeStep === \"vary\";\n  useFrame((_, dt) => {\n    const world = worldRef.current;\n    if (!world) return;\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.2);\n\n    if (timeStepVariable) {\n      world.timestep = clampedDelta;\n      if (!_paused) world.step(eventQueue);\n    } else {\n      world.timestep = _timeStep; // don't step time forwards if paused\n      // Increase accumulator\n\n      steppingState.accumulator += _paused ? 0 : clampedDelta;\n\n      if (!_paused) {\n        while (steppingState.accumulator >= _timeStep) {\n          world.step(eventQueue);\n          steppingState.accumulator -= _timeStep;\n        }\n      }\n    }\n\n    const interpolationAlpha = timeStepVariable ? 1 : steppingState.accumulator % _timeStep / _timeStep; // Update meshes\n\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n\n        state.isSleeping = rigidBody.isSleeping();\n      }\n\n      if (!rigidBody || rigidBody.isSleeping() || !state.setMatrix) {\n        return;\n      }\n\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation(); // Get new position\n\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n      if (state.object instanceof InstancedMesh) {\n        state.setMatrix(_matrix4);\n        state.object.instanceMatrix.needsUpdate = true;\n      } else {\n        // Interpolate from last position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      var _collider1$parent, _collider2$parent;\n\n      const collider1 = world.getCollider(handle1);\n      const collider2 = world.getCollider(handle2);\n      const rigidBodyHandle1 = (_collider1$parent = collider1.parent()) === null || _collider1$parent === void 0 ? void 0 : _collider1$parent.handle;\n      const rigidBodyHandle2 = (_collider2$parent = collider2.parent()) === null || _collider2$parent === void 0 ? void 0 : _collider2$parent.handle; // Collision Events\n\n      if (!collider1 || !collider2) {\n        return;\n      }\n\n      const collider1Events = colliderEvents.get(collider1.handle);\n      const collider2Events = colliderEvents.get(collider2.handle);\n      const rigidBody1 = rigidBodyHandle1 ? world.getRigidBody(rigidBodyHandle1) : undefined;\n      const rigidBody2 = rigidBodyHandle2 ? world.getRigidBody(rigidBodyHandle2) : undefined;\n      const rigidBody1Events = rigidBodyHandle1 ? rigidBodyEvents.get(rigidBodyHandle1) : undefined;\n      const rigidBody2Events = rigidBodyHandle2 ? rigidBodyEvents.get(rigidBodyHandle2) : undefined;\n      const collider1State = colliderStates.get(collider1.handle);\n      const collider2State = colliderStates.get(collider2.handle);\n      const rigidBody1State = rigidBodyHandle1 ? rigidBodyStates.get(rigidBodyHandle1) : undefined;\n      const rigidBody2State = rigidBodyHandle2 ? rigidBodyStates.get(rigidBodyHandle2) : undefined;\n\n      if (started) {\n        world.contactPair(collider1, collider2, (manifold, flipped) => {\n          var _rigidBody1Events$onC, _rigidBody2Events$onC, _collider1Events$onCo, _collider2Events$onCo;\n\n          /* RigidBody events */\n          rigidBody1Events === null || rigidBody1Events === void 0 ? void 0 : (_rigidBody1Events$onC = rigidBody1Events.onCollisionEnter) === null || _rigidBody1Events$onC === void 0 ? void 0 : _rigidBody1Events$onC.call(rigidBody1Events, {\n            rigidBody: rigidBody2,\n            collider: collider2,\n            colliderObject: collider2State === null || collider2State === void 0 ? void 0 : collider2State.object,\n            rigidBodyObject: rigidBody2State === null || rigidBody2State === void 0 ? void 0 : rigidBody2State.object,\n            manifold,\n            flipped\n          });\n          rigidBody2Events === null || rigidBody2Events === void 0 ? void 0 : (_rigidBody2Events$onC = rigidBody2Events.onCollisionEnter) === null || _rigidBody2Events$onC === void 0 ? void 0 : _rigidBody2Events$onC.call(rigidBody2Events, {\n            rigidBody: rigidBody1,\n            collider: collider1,\n            colliderObject: collider1State === null || collider1State === void 0 ? void 0 : collider1State.object,\n            rigidBodyObject: rigidBody1State === null || rigidBody1State === void 0 ? void 0 : rigidBody1State.object,\n            manifold,\n            flipped\n          });\n          /* Collider events */\n\n          collider1Events === null || collider1Events === void 0 ? void 0 : (_collider1Events$onCo = collider1Events.onCollisionEnter) === null || _collider1Events$onCo === void 0 ? void 0 : _collider1Events$onCo.call(collider1Events, {\n            rigidBody: rigidBody2,\n            collider: collider2,\n            colliderObject: collider2State === null || collider2State === void 0 ? void 0 : collider2State.object,\n            rigidBodyObject: rigidBody2State === null || rigidBody2State === void 0 ? void 0 : rigidBody2State.object,\n            manifold,\n            flipped\n          });\n          collider2Events === null || collider2Events === void 0 ? void 0 : (_collider2Events$onCo = collider2Events.onCollisionEnter) === null || _collider2Events$onCo === void 0 ? void 0 : _collider2Events$onCo.call(collider2Events, {\n            rigidBody: rigidBody1,\n            collider: collider1,\n            colliderObject: collider1State === null || collider1State === void 0 ? void 0 : collider1State.object,\n            rigidBodyObject: rigidBody1State === null || rigidBody1State === void 0 ? void 0 : rigidBody1State.object,\n            manifold,\n            flipped\n          });\n        });\n      } else {\n        var _rigidBody1Events$onC2, _rigidBody2Events$onC2, _collider1Events$onCo2, _collider2Events$onCo2;\n\n        rigidBody1Events === null || rigidBody1Events === void 0 ? void 0 : (_rigidBody1Events$onC2 = rigidBody1Events.onCollisionExit) === null || _rigidBody1Events$onC2 === void 0 ? void 0 : _rigidBody1Events$onC2.call(rigidBody1Events, {\n          rigidBody: rigidBody2,\n          collider: collider2\n        });\n        rigidBody2Events === null || rigidBody2Events === void 0 ? void 0 : (_rigidBody2Events$onC2 = rigidBody2Events.onCollisionExit) === null || _rigidBody2Events$onC2 === void 0 ? void 0 : _rigidBody2Events$onC2.call(rigidBody2Events, {\n          rigidBody: rigidBody1,\n          collider: collider1\n        });\n        collider1Events === null || collider1Events === void 0 ? void 0 : (_collider1Events$onCo2 = collider1Events.onCollisionExit) === null || _collider1Events$onCo2 === void 0 ? void 0 : _collider1Events$onCo2.call(collider1Events, {\n          rigidBody: rigidBody2,\n          collider: collider2\n        });\n        collider2Events === null || collider2Events === void 0 ? void 0 : (_collider2Events$onCo2 = collider2Events.onCollisionExit) === null || _collider2Events$onCo2 === void 0 ? void 0 : _collider2Events$onCo2.call(collider2Events, {\n          rigidBody: rigidBody1,\n          collider: collider1\n        });\n      } // Sensor Intersections\n\n\n      if (started) {\n        if (world.intersectionPair(collider1, collider2)) {\n          var _rigidBody1Events$onI, _rigidBody2Events$onI, _collider1Events$onIn, _collider2Events$onIn;\n\n          rigidBody1Events === null || rigidBody1Events === void 0 ? void 0 : (_rigidBody1Events$onI = rigidBody1Events.onIntersectionEnter) === null || _rigidBody1Events$onI === void 0 ? void 0 : _rigidBody1Events$onI.call(rigidBody1Events, {\n            rigidBody: rigidBody2,\n            collider: collider2,\n            colliderObject: collider2State === null || collider2State === void 0 ? void 0 : collider2State.object,\n            rigidBodyObject: rigidBody2State === null || rigidBody2State === void 0 ? void 0 : rigidBody2State.object\n          });\n          rigidBody2Events === null || rigidBody2Events === void 0 ? void 0 : (_rigidBody2Events$onI = rigidBody2Events.onIntersectionEnter) === null || _rigidBody2Events$onI === void 0 ? void 0 : _rigidBody2Events$onI.call(rigidBody2Events, {\n            rigidBody: rigidBody1,\n            collider: collider1,\n            colliderObject: collider1State === null || collider1State === void 0 ? void 0 : collider1State.object,\n            rigidBodyObject: rigidBody1State === null || rigidBody1State === void 0 ? void 0 : rigidBody1State.object\n          });\n          collider1Events === null || collider1Events === void 0 ? void 0 : (_collider1Events$onIn = collider1Events.onIntersectionEnter) === null || _collider1Events$onIn === void 0 ? void 0 : _collider1Events$onIn.call(collider1Events, {\n            rigidBody: rigidBody2,\n            collider: collider2,\n            colliderObject: collider2State === null || collider2State === void 0 ? void 0 : collider2State.object,\n            rigidBodyObject: rigidBody2State === null || rigidBody2State === void 0 ? void 0 : rigidBody2State.object\n          });\n          collider2Events === null || collider2Events === void 0 ? void 0 : (_collider2Events$onIn = collider2Events.onIntersectionEnter) === null || _collider2Events$onIn === void 0 ? void 0 : _collider2Events$onIn.call(collider2Events, {\n            rigidBody: rigidBody1,\n            collider: collider1,\n            colliderObject: collider1State === null || collider1State === void 0 ? void 0 : collider1State.object,\n            rigidBodyObject: rigidBody1State === null || rigidBody1State === void 0 ? void 0 : rigidBody1State.object\n          });\n        }\n      } else {\n        var _rigidBody1Events$onI2, _rigidBody2Events$onI2, _collider1Events$onIn2, _collider2Events$onIn2;\n\n        rigidBody1Events === null || rigidBody1Events === void 0 ? void 0 : (_rigidBody1Events$onI2 = rigidBody1Events.onIntersectionExit) === null || _rigidBody1Events$onI2 === void 0 ? void 0 : _rigidBody1Events$onI2.call(rigidBody1Events, {\n          rigidBody: rigidBody2,\n          collider: collider2\n        });\n        rigidBody2Events === null || rigidBody2Events === void 0 ? void 0 : (_rigidBody2Events$onI2 = rigidBody2Events.onIntersectionExit) === null || _rigidBody2Events$onI2 === void 0 ? void 0 : _rigidBody2Events$onI2.call(rigidBody2Events, {\n          rigidBody: rigidBody1,\n          collider: collider1\n        });\n        collider1Events === null || collider1Events === void 0 ? void 0 : (_collider1Events$onIn2 = collider1Events.onIntersectionExit) === null || _collider1Events$onIn2 === void 0 ? void 0 : _collider1Events$onIn2.call(collider1Events, {\n          rigidBody: rigidBody2,\n          collider: collider2\n        });\n        collider2Events === null || collider2Events === void 0 ? void 0 : (_collider2Events$onIn2 = collider2Events.onIntersectionExit) === null || _collider2Events$onIn2 === void 0 ? void 0 : _collider2Events$onIn2.call(collider2Events, {\n          rigidBody: rigidBody1,\n          collider: collider1\n        });\n      }\n    });\n  }, updatePriority);\n  const api = useMemo(() => createWorldApi(getWorldRef), []);\n  const context = useMemo(() => ({\n    rapier,\n    world: api,\n    physicsOptions: {\n      colliders: _colliders,\n      gravity: _gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    isPaused: _paused\n  }), [_paused]);\n  return /*#__PURE__*/React.createElement(RapierContext.Provider, {\n    value: context\n  }, children);\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst rigidBodyDescFromOptions = options => {\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type);\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false\n  };\n};\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n\n  const state = states.get(rigidBody.handle);\n\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (rigidBodyRef, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    if (Array.isArray(rigidBodyRef.current)) {\n      for (const rigidBody of rigidBodyRef.current) {\n        setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n      }\n    } else if (rigidBodyRef.current) {\n      setRigidBodyOptions(rigidBodyRef.current, props, states, updateTranslations);\n    }\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (rigidBodyRef, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit\n  };\n  useEffect(() => {\n    if (Array.isArray(rigidBodyRef.current)) {\n      for (const rigidBody of rigidBodyRef.current) {\n        events.set(rigidBody.handle, eventHandlers);\n      }\n    } else if (rigidBodyRef.current) {\n      events.set(rigidBodyRef.current.handle, eventHandlers);\n    }\n\n    return () => {\n      if (Array.isArray(rigidBodyRef.current)) {\n        for (const rigidBody of rigidBodyRef.current) {\n          events.delete(rigidBody.handle);\n        }\n      } else if (rigidBodyRef.current) {\n        events.delete(rigidBodyRef.current.handle);\n      }\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit]);\n};\n\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice(); // Heightfield uses a vector\n\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  } // Trimesh and convex scale the vertices\n\n\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  } // Prepfill with some extra\n\n\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, rigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore\n\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, rigidBody);\n};\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\n\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setDensity(options.density);\n    return;\n  }\n\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setMass(options.mass);\n    return;\n  }\n\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\n\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  // To make sure the options all mutalbe options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n\n  if (state) {\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    state.object.updateWorldMatrix(true, false);\n\n    _matrix4.copy(state.object.matrixWorld).premultiply(state.worldParent.matrixWorld.clone().invert()).decompose(_position, _rotation, _scale);\n\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider, // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    }); // handle mass separately, because the assignments\n    // are exclusive.\n\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (collidersRef, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    collidersRef.current.forEach(collider => {\n      setColliderOptions(collider, props, states);\n    });\n  }, mutablePropsAsFlatArray);\n};\n\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\n\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || object.parent,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const colliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  object.traverseVisible(child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      colliderProps.push(_objectSpread2(_objectSpread2({}, options), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      }));\n    }\n  });\n  return colliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst useColliderEvents = (collidersRef, props, events) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit\n  } = props;\n  useEffect(() => {\n    var _collidersRef$current;\n\n    (_collidersRef$current = collidersRef.current) === null || _collidersRef$current === void 0 ? void 0 : _collidersRef$current.forEach(collider => {\n      if (onCollisionEnter || onCollisionExit || onIntersectionEnter || onIntersectionExit) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      }\n\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit\n      });\n    });\n    return () => {\n      var _collidersRef$current2;\n\n      (_collidersRef$current2 = collidersRef.current) === null || _collidersRef$current2 === void 0 ? void 0 : _collidersRef$current2.forEach(collider => events.delete(collider.handle));\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit]);\n};\n\nconst useRapier = () => {\n  return useContext(RapierContext);\n};\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\nconst useRigidBody = (options = {}) => {\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const ref = useRef();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(ref, mergedOptions); // Create rigidbody\n\n  const rigidBodyRef = useRef();\n  const getRigidBodyRef = useRef(() => {\n    if (!rigidBodyRef.current) {\n      const desc = rigidBodyDescFromOptions(options);\n      const rigidBody = world.createRigidBody(desc);\n      rigidBodyRef.current = world.getRigidBody(rigidBody.handle);\n    }\n\n    return rigidBodyRef.current;\n  }); // Setup\n\n  useEffect(() => {\n    const rigidBody = getRigidBodyRef.current();\n    rigidBodyRef.current = rigidBody;\n\n    if (!ref.current) {\n      ref.current = new Object3D();\n    } // isSleeping used for onSleep and onWake events\n\n\n    ref.current.userData.isSleeping = false;\n    rigidBodyStates.set(rigidBody.handle, createRigidBodyState({\n      rigidBody,\n      object: ref.current\n    }));\n    return () => {\n      world.removeRigidBody(rigidBody);\n      rigidBodyStates.delete(rigidBody.handle);\n      rigidBodyRef.current = undefined;\n    };\n  }, []);\n  useUpdateRigidBodyOptions(rigidBodyRef, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(rigidBodyRef, mergedOptions, rigidBodyEvents);\n  const api = useMemo(() => createRigidBodyApi(getRigidBodyRef), []);\n  return [ref, api, childColliderProps];\n}; // Joints\n\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef();\n  const getJointRef = useRef(() => {\n    if (!jointRef.current) {\n      let rb1;\n      let rb2;\n\n      if (\"current\" in body1 && body1.current && \"current\" in body2 && body2.current) {\n        rb1 = world.getRigidBody(body1.current.handle);\n        rb2 = world.getRigidBody(body2.current.handle);\n        const newJoint = world.createImpulseJoint(params, rb1, rb2);\n        jointRef.current = newJoint;\n      }\n    }\n\n    return jointRef.current;\n  });\n  useEffect(() => {\n    const joint = getJointRef.current();\n    return () => {\n      if (joint) {\n        world.removeImpulseJoint(joint);\n        jointRef.current = undefined;\n      }\n    };\n  }, []);\n  const api = useMemo(() => createJointApi(getJointRef), []);\n  return api;\n};\n/**\n *\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n */\n\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vectorArrayToVector3(body1Anchor), _objectSpread2(_objectSpread2({}, vectorArrayToVector3(body1LocalFrame)), {}, {\n    w: 1\n  }), vectorArrayToVector3(body2Anchor), _objectSpread2(_objectSpread2({}, vectorArrayToVector3(body2LocalFrame)), {}, {\n    w: 1\n  })));\n};\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n */\n\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor)));\n};\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n */\n\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.revolute(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis)));\n};\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n */\n\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.prismatic(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis)));\n};\n\n// Colliders\nconst AnyCollider = /*#__PURE__*/memo( /*#__PURE__*/React.forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const ref = useRef(null);\n  const collidersRef = useMemo(() => {\n    if (forwardedRef !== null) {\n      return forwardedRef;\n    }\n\n    const result = /*#__PURE__*/React.createRef();\n    result.current = [];\n    return result;\n  }, []);\n  useEffect(() => {\n    const object = ref.current;\n    const worldScale = object.getWorldScale(new Vector3());\n    const colliders = []; // If this is an InstancedRigidBody api\n\n    if (rigidBodyContext && \"at\" in rigidBodyContext.api) {\n      rigidBodyContext.api.forEach((body, index) => {\n        var _rigidBodyContext$opt, _rigidBodyContext$opt2;\n\n        let instanceScale = worldScale;\n\n        if (\"scales\" in rigidBodyContext.options && rigidBodyContext !== null && rigidBodyContext !== void 0 && (_rigidBodyContext$opt = rigidBodyContext.options) !== null && _rigidBodyContext$opt !== void 0 && (_rigidBodyContext$opt2 = _rigidBodyContext$opt.scales) !== null && _rigidBodyContext$opt2 !== void 0 && _rigidBodyContext$opt2[index]) {\n          instanceScale = instanceScale.clone().multiply(vectorArrayToVector3(rigidBodyContext.options.scales[index]));\n        }\n\n        const collider = createColliderFromOptions(props, world, instanceScale, body.raw());\n        colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n        colliders.push(collider);\n      });\n    } else {\n      const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext && (rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.api).raw());\n      colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n      colliders.push(collider);\n    }\n\n    collidersRef.current = colliders;\n    return () => {\n      colliders.forEach(collider => {\n        world.removeCollider(collider);\n      });\n    };\n  }, []);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(collidersRef, mergedProps, colliderStates);\n  useColliderEvents(collidersRef, mergedProps, colliderEvents);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: ref\n  }, children);\n}));\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"roundCuboid\",\n    ref: ref\n  }));\n});\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"ball\",\n    ref: ref\n  }));\n});\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"capsule\",\n    ref: ref\n  }));\n});\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"heightfield\",\n    ref: ref\n  }));\n});\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"trimesh\",\n    ref: ref\n  }));\n});\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cone\",\n    ref: ref\n  }));\n});\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cylinder\",\n    ref: ref\n  }));\n});\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"convexHull\",\n    ref: ref\n  }));\n});\n\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\nconst RigidBody = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, ref) => {\n  const {\n    children,\n    type,\n    position,\n    rotation,\n    scale,\n    quaternion\n  } = props,\n        objectProps = _objectWithoutProperties(props, _excluded$1);\n\n  const [object, api, childColliderProps] = useRigidBody(props);\n  useImperativeHandle(ref, () => api);\n  const contextValue = useMemo(() => ({\n    ref: object,\n    api,\n    options: props\n  }), [object, api, props]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: object\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\n\nconst MeshCollider = props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions,\n    world\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n};\n\nconst geometryFromCollider = collider => {\n  switch (collider.shape.type) {\n    case ShapeType.Cuboid:\n      {\n        const {\n          x,\n          y,\n          z\n        } = collider.shape.halfExtents;\n        return new BoxGeometry(x * 2 + 0.01, y * 2 + 0.01, z * 2 + 0.01);\n      }\n\n    case ShapeType.RoundCuboid:\n      {\n        const {\n          x,\n          y,\n          z\n        } = collider.shape.halfExtents;\n        const radius = collider.shape.borderRadius;\n        return new RoundedBoxGeometry(x * 2 + radius * 2, y * 2 + radius * 2, z * 2 + radius * 2, 8, radius);\n      }\n\n    case ShapeType.Ball:\n      {\n        const r = collider.shape.radius;\n        return new SphereGeometry(r + +0.01, 8, 8);\n      }\n\n    case ShapeType.TriMesh:\n      {\n        var _g$index;\n\n        const v = collider.shape.vertices;\n        const i = collider.shape.indices;\n        const g = new BufferGeometry(); // Vertices are not always a float3darray (???), so we need to convert them\n\n        const safeVerts = Float32Array.from(v);\n        g.setAttribute(\"position\", new BufferAttribute(safeVerts, 3));\n        (_g$index = g.index) === null || _g$index === void 0 ? void 0 : _g$index.set(i);\n        g.setDrawRange(0, g.attributes.position.array.length / 3 - 1);\n        return g;\n      }\n\n    case ShapeType.ConvexPolyhedron:\n      {\n        const cv = collider.shape.vertices; // Vertices are not always a float3darray (???), so we need to convert them\n\n        const safeVerts = Float32Array.from(cv);\n        const cg = new BufferGeometry();\n        cg.setAttribute(\"position\", new BufferAttribute(safeVerts, 3));\n        return cg;\n      }\n\n    case ShapeType.Cylinder:\n      {\n        const r = collider.shape.radius;\n        const h = collider.shape.halfHeight;\n        const g = new CylinderGeometry(r, r, h * 2);\n        return g;\n      }\n\n    case ShapeType.Capsule:\n      {\n        const r = collider.shape.radius;\n        const h = collider.shape.halfHeight;\n        const g = new CapsuleGeometry(r, h * 2, 4, 8);\n        return g;\n      }\n\n    case ShapeType.Cone:\n      {\n        const r = collider.shape.radius;\n        const h = collider.shape.halfHeight;\n        const g = new ConeGeometry(r, h * 2, 16);\n        return g;\n      }\n\n    case ShapeType.HeightField:\n      {\n        const rows = collider.shape.nrows;\n        const cols = collider.shape.ncols;\n        const heights = collider.shape.heights;\n        const scale = collider.shape.scale;\n        const g = new PlaneGeometry(scale.x, scale.z, cols, rows);\n        const verts = g.attributes.position.array;\n        verts.forEach((v, index) => verts[index * 3 + 2] = heights[index] * scale.y);\n        g.scale(1, -1, 1);\n        g.rotateX(-Math.PI / 2);\n        g.rotateY(-Math.PI / 2);\n        return g;\n      }\n  }\n\n  return new BoxGeometry(1, 1, 1);\n};\n\nconst DebugShape = /*#__PURE__*/memo(({\n  colliderHandle,\n  color,\n  sleepColor\n}) => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  const [material] = useState(new MeshBasicMaterial({\n    color,\n    wireframe: true\n  }));\n  useFrame(() => {\n    const collider = world.getCollider(colliderHandle);\n\n    if (ref.current && collider) {\n      const {\n        x: rx,\n        y: ry,\n        z: rz,\n        w: rw\n      } = collider.rotation();\n      const {\n        x,\n        y,\n        z\n      } = collider.translation();\n      const parent = collider.parent();\n\n      if (parent !== null && parent !== void 0 && parent.isSleeping() || parent !== null && parent !== void 0 && parent.isFixed() || parent !== null && parent !== void 0 && parent.isKinematic()) {\n        material.color = new Color(sleepColor);\n      } else {\n        material.color = new Color(color);\n      }\n\n      ref.current.position.set(x, y, z);\n      ref.current.rotation.setFromQuaternion(new Quaternion(rx, ry, rz, rw));\n    }\n  });\n  const geometry = useMemo(() => {\n    const collider = world.getCollider(colliderHandle);\n    return geometryFromCollider(collider);\n  }, [colliderHandle]);\n  return /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: ref,\n    material: material\n  }, /*#__PURE__*/React.createElement(\"primitive\", {\n    object: geometry,\n    attach: \"geometry\"\n  }));\n});\nconst Debug = ({\n  color: _color = \"red\",\n  sleepColor: _sleepColor = \"blue\"\n}) => {\n  const {\n    world\n  } = useRapier();\n  const [colliders, setColliders] = useState([]);\n  useRef({});\n\n  useFrame(() => {\n    const newColliders = [];\n    world.forEachCollider(collider => {\n      newColliders.push(collider.handle);\n    });\n    setColliders(newColliders);\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, colliders.map(handle => /*#__PURE__*/React.createElement(DebugShape, {\n    key: handle,\n    colliderHandle: handle,\n    color: _color,\n    sleepColor: _sleepColor\n  })));\n};\n\nconst _excluded = [\"positions\", \"rotations\", \"children\"];\nconst InstancedRigidBodies = /*#__PURE__*/forwardRef((props, ref) => {\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const object = useRef(null);\n\n  const {\n    positions,\n    rotations,\n    children\n  } = props,\n        options = _objectWithoutProperties(props, _excluded);\n\n  const instancesRef = useRef([]);\n  const rigidBodyRefs = useRef([]);\n  const instancesRefGetter = useRef(() => {\n    if (!instancesRef.current) {\n      instancesRef.current = [];\n    }\n\n    return instancesRef.current;\n  });\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, physicsOptions), options);\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions);\n  useLayoutEffect(() => {\n    object.current.updateWorldMatrix(true, false);\n    const instances = instancesRefGetter.current();\n    const invertedWorld = object.current.matrixWorld.clone().invert();\n    object.current.traverseVisible(mesh => {\n      if (mesh instanceof InstancedMesh) {\n        mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n        const worldScale = mesh.getWorldScale(_scale);\n\n        for (let index = 0; index < mesh.count; index++) {\n          var _options$scales;\n\n          const desc = rigidBodyDescFromOptions(props);\n          const rigidBody = world.createRigidBody(desc);\n          rigidBodyRefs.current.push(rigidBody);\n          const scale = ((_options$scales = options.scales) === null || _options$scales === void 0 ? void 0 : _options$scales[index]) || [1, 1, 1];\n          const instanceScale = worldScale.clone().multiply(vectorArrayToVector3(scale));\n          rigidBodyStates.set(rigidBody.handle, createRigidBodyState({\n            rigidBody,\n            object: mesh,\n            setMatrix: matrix => mesh.setMatrixAt(index, matrix),\n            getMatrix: matrix => {\n              mesh.getMatrixAt(index, matrix);\n              return matrix;\n            },\n            worldScale: instanceScale\n          }));\n          const [x, y, z] = (positions === null || positions === void 0 ? void 0 : positions[index]) || [0, 0, 0];\n          const [rx, ry, rz] = (rotations === null || rotations === void 0 ? void 0 : rotations[index]) || [0, 0, 0];\n\n          _object3d.position.set(x, y, z);\n\n          _object3d.rotation.set(rx, ry, rz);\n\n          _object3d.applyMatrix4(invertedWorld);\n\n          mesh.setMatrixAt(index, _object3d.matrix);\n          rigidBody.setTranslation(_object3d.position, false);\n          rigidBody.setRotation(_object3d.quaternion, false);\n          const api = createRigidBodyApi({\n            current() {\n              return rigidBody;\n            }\n\n          });\n          instances.push({\n            rigidBody,\n            api\n          });\n        }\n      }\n    });\n    return () => {\n      instances.forEach(rb => {\n        world.removeRigidBody(rb.rigidBody);\n        rigidBodyStates.delete(rb.rigidBody.handle);\n      });\n      rigidBodyRefs.current = [];\n      instancesRef.current = [];\n    };\n  }, []);\n  const api = useMemo(() => createInstancedRigidBodiesApi(instancesRefGetter), []);\n  useImperativeHandle(ref, () => api);\n  useUpdateRigidBodyOptions(rigidBodyRefs, mergedOptions, rigidBodyStates, false);\n  useRigidBodyEvents(rigidBodyRefs, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: object,\n      api,\n      options: mergedOptions\n    };\n  }, [api, mergedOptions]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object\n  }, props.children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n});\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\n\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, Debug, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundCuboidCollider, TrimeshCollider, interactionGroups, useChildColliderProps, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRigidBody, useSphericalJoint };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}