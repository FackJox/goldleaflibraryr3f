{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GastRecorder = void 0;\nvar last_1 = __importDefault(require(\"lodash/last\"));\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar some_1 = __importDefault(require(\"lodash/some\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar isFunction_1 = __importDefault(require(\"lodash/isFunction\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar gast_1 = require(\"@chevrotain/gast\");\nvar lexer_public_1 = require(\"../../../scan/lexer_public\");\nvar tokens_1 = require(\"../../../scan/tokens\");\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar parser_1 = require(\"../parser\");\nvar keys_1 = require(\"../../grammar/keys\");\nvar RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = (0, tokens_public_1.createToken)({\n  name: \"RECORDING_PHASE_TOKEN\",\n  pattern: lexer_public_1.Lexer.NA\n});\n(0, tokens_1.augmentTokenTypes)([RFT]);\nvar RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" + \"\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n  name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nvar GastRecorder = /** @class */function () {\n  function GastRecorder() {}\n  GastRecorder.prototype.initGastRecorder = function (config) {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  };\n  GastRecorder.prototype.enableRecording = function () {\n    var _this = this;\n    this.RECORDING_PHASE = true;\n    this.TRACE_INIT(\"Enable Recording\", function () {\n      var _loop_1 = function _loop_1(i) {\n        var idx = i > 0 ? i : \"\";\n        _this[\"CONSUME\".concat(idx)] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n        _this[\"SUBRULE\".concat(idx)] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2);\n        };\n        _this[\"OPTION\".concat(idx)] = function (arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n        _this[\"OR\".concat(idx)] = function (arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n        _this[\"MANY\".concat(idx)] = function (arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n        _this[\"MANY_SEP\".concat(idx)] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n        _this[\"AT_LEAST_ONE\".concat(idx)] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n        _this[\"AT_LEAST_ONE_SEP\".concat(idx)] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      };\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n      for (var i = 0; i < 10; i++) {\n        _loop_1(i);\n      }\n      // DSL methods with the idx(suffix) as an argument\n      _this[\"consume\"] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n      _this[\"subrule\"] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2);\n      };\n      _this[\"option\"] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n      _this[\"or\"] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n      _this[\"many\"] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n      _this[\"atLeastOne\"] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n      _this.ACTION = _this.ACTION_RECORD;\n      _this.BACKTRACK = _this.BACKTRACK_RECORD;\n      _this.LA = _this.LA_RECORD;\n    });\n  };\n  GastRecorder.prototype.disableRecording = function () {\n    var _this = this;\n    this.RECORDING_PHASE = false;\n    // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n    this.TRACE_INIT(\"Deleting Recording methods\", function () {\n      var that = _this;\n      for (var i = 0; i < 10; i++) {\n        var idx = i > 0 ? i : \"\";\n        delete that[\"CONSUME\".concat(idx)];\n        delete that[\"SUBRULE\".concat(idx)];\n        delete that[\"OPTION\".concat(idx)];\n        delete that[\"OR\".concat(idx)];\n        delete that[\"MANY\".concat(idx)];\n        delete that[\"MANY_SEP\".concat(idx)];\n        delete that[\"AT_LEAST_ONE\".concat(idx)];\n        delete that[\"AT_LEAST_ONE_SEP\".concat(idx)];\n      }\n      delete that[\"consume\"];\n      delete that[\"subrule\"];\n      delete that[\"option\"];\n      delete that[\"or\"];\n      delete that[\"many\"];\n      delete that[\"atLeastOne\"];\n      delete that.ACTION;\n      delete that.BACKTRACK;\n      delete that.LA;\n    });\n  };\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  // @ts-expect-error -- noop place holder\n  GastRecorder.prototype.ACTION_RECORD = function (impl) {\n    // NO-OP during recording\n  };\n  // Executing backtracking logic will break our recording logic assumptions\n  GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n    return function () {\n      return true;\n    };\n  };\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  GastRecorder.prototype.LA_RECORD = function (howMuch) {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return parser_1.END_OF_FILE;\n  };\n  GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n    try {\n      var newTopLevelRule = new gast_1.Rule({\n        definition: [],\n        name: name\n      });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message = originalError.message + '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' + \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError;\n        }\n      }\n      throw originalError;\n    }\n  };\n  // Implementation of parsing DSL\n  GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n    return recordProd.call(this, gast_1.Option, actionORMethodDef, occurrence);\n  };\n  GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, gast_1.RepetitionMandatory, actionORMethodDef, occurrence);\n  };\n  GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, gast_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n  GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, gast_1.Repetition, actionORMethodDef, occurrence);\n  };\n  GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, gast_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n  GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  };\n  GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!ruleToCall || (0, has_1.default)(ruleToCall, \"ruleName\") === false) {\n      var error = new Error(\"<SUBRULE\".concat(getIdxSuffix(occurrence), \"> argument is invalid\") + \" expecting a Parser method reference but got: <\".concat(JSON.stringify(ruleToCall), \">\") + \"\\n inside top level rule: <\".concat(this.recordingProdStack[0].name, \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    var prevProd = (0, last_1.default)(this.recordingProdStack);\n    var ruleName = ruleToCall.ruleName;\n    var newNoneTerminal = new gast_1.NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options === null || options === void 0 ? void 0 : options.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n  };\n  GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {\n      var error = new Error(\"<CONSUME\".concat(getIdxSuffix(occurrence), \"> argument is invalid\") + \" expecting a TokenType reference but got: <\".concat(JSON.stringify(tokType), \">\") + \"\\n inside top level rule: <\".concat(this.recordingProdStack[0].name, \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    var prevProd = (0, last_1.default)(this.recordingProdStack);\n    var newNoneTerminal = new gast_1.Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options === null || options === void 0 ? void 0 : options.LABEL\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return RECORDING_PHASE_TOKEN;\n  };\n  return GastRecorder;\n}();\nexports.GastRecorder = GastRecorder;\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n  if (handleSep === void 0) {\n    handleSep = false;\n  }\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = (0, last_1.default)(this.recordingProdStack);\n  var grammarAction = (0, isFunction_1.default)(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n  var newProd = new prodConstructor({\n    definition: [],\n    idx: occurrence\n  });\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n  if ((0, has_1.default)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n  return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n  var _this = this;\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = (0, last_1.default)(this.recordingProdStack);\n  // Only an array of alternatives\n  var hasOptions = (0, isArray_1.default)(mainProdArg) === false;\n  var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n  var newOrProd = new gast_1.Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  });\n  if ((0, has_1.default)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  var hasPredicates = (0, some_1.default)(alts, function (currAlt) {\n    return (0, isFunction_1.default)(currAlt.GATE);\n  });\n  newOrProd.hasPredicates = hasPredicates;\n  prevProd.definition.push(newOrProd);\n  (0, forEach_1.default)(alts, function (currAlt) {\n    var currAltFlat = new gast_1.Alternative({\n      definition: []\n    });\n    newOrProd.definition.push(currAltFlat);\n    if ((0, has_1.default)(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES; // assumes end user provides the correct config value/type\n    }\n    // **implicit** ignoreAmbiguities due to usage of gate\n    else if ((0, has_1.default)(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n    _this.recordingProdStack.push(currAltFlat);\n    currAlt.ALT.call(_this);\n    _this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n  return idx === 0 ? \"\" : \"\".concat(idx);\n}\nfunction assertMethodIdxIsValid(idx) {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    var error = new Error(\n    // The stack trace will contain all the needed details\n    \"Invalid DSL Method idx value: <\".concat(idx, \">\\n\\t\") + \"Idx value must be a none negative value smaller than \".concat(MAX_METHOD_IDX + 1));\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/gast_recorder.ts"],"names":[],"mappings":";;;;;;;;;;;AAgBA,IAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;AACA,IAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;AACA,IAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;AACA,IAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;AACA,IAAA,YAAA,GAAA,eAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;AACA,IAAA,KAAA,GAAA,eAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;AAEA,IAAA,MAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAYA,IAAA,cAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,6BAAA,CAAA;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AAIA,IAAM,qBAAqB,GAAG;EAC5B,WAAW,EAAE;CACd;AACD,MAAM,CAAC,MAAM,CAAC,qBAAqB,CAAC;AAEpC,IAAM,gBAAgB,GAAG,IAAI;AAC7B,IAAM,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,MAAA,CAAA,uBAAuB,CAAC,GAAG,CAAC;AAE/D,IAAM,GAAG,GAAG,CAAA,CAAA,EAAA,eAAA,CAAA,WAAW,EAAC;EAAE,IAAI,EAAE,uBAAuB;EAAE,OAAO,EAAE,cAAA,CAAA,KAAK,CAAC;AAAE,CAAE,CAAC;AAC7E,CAAA,CAAA,EAAA,QAAA,CAAA,iBAAiB,EAAC,CAAC,GAAG,CAAC,CAAC;AACxB,IAAM,qBAAqB,GAAG,CAAA,CAAA,EAAA,eAAA,CAAA,mBAAmB,EAC/C,GAAG,EACH,4DAA4D,GAC1D,EAAE,GACF,oFAAoF;AACtF;AACA;AACA,CAAC,CAAC,EACF,CAAC,CAAC,EACF,CAAC,CAAC,EACF,CAAC,CAAC,EACF,CAAC,CAAC,EACF,CAAC,CAAC,CACH;AACD,MAAM,CAAC,MAAM,CAAC,qBAAqB,CAAC;AAEpC,IAAM,uBAAuB,GAAY;EACvC,IAAI,EACF,6DAA6D,GAC7D,oFAAoF;EACtF,QAAQ,EAAE,CAAA;CACX;AAED;;AAEG;AACH,IAAA,YAAA,GAAA,aAAA,YAAA;EAAA,SAAA,YAAA,GAAA,CA2RA;EAvRE,YAAA,CAAA,SAAA,CAAA,gBAAgB,GAAhB,UAAsC,MAAqB,EAAA;IACzD,IAAI,CAAC,kBAAkB,GAAG,EAAE;IAC5B,IAAI,CAAC,eAAe,GAAG,KAAK;EAC9B,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,eAAe,GAAf,YAAA;IAAA,IAAA,KAAA,GAAA,IAAA;IACE,IAAI,CAAC,eAAe,GAAG,IAAI;IAE3B,IAAI,CAAC,UAAU,CAAC,kBAAkB,EAAE,YAAA;qCAUzB,CAAC,EAAA;QACR,IAAM,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE;QAC1B,KAAI,CAAC,SAAA,CAAA,MAAA,CAAU,GAAG,CAAe,CAAC,GAAG,UAAU,IAAI,EAAE,IAAI,EAAA;UACvD,OAAO,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC;QAClD,CAAC;QACD,KAAI,CAAC,SAAA,CAAA,MAAA,CAAU,GAAG,CAAe,CAAC,GAAG,UAAU,IAAI,EAAE,IAAI,EAAA;UACvD,OAAO,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,CAAC,EAAE,IAAI,CAAQ;QACzD,CAAC;QACD,KAAI,CAAC,QAAA,CAAA,MAAA,CAAS,GAAG,CAAc,CAAC,GAAG,UAAU,IAAI,EAAA;UAC/C,OAAO,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,CAAC,CAAC;QAC3C,CAAC;QACD,KAAI,CAAC,IAAA,CAAA,MAAA,CAAK,GAAG,CAAU,CAAC,GAAG,UAAU,IAAI,EAAA;UACvC,OAAO,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,CAAC,CAAC;QACvC,CAAC;QACD,KAAI,CAAC,MAAA,CAAA,MAAA,CAAO,GAAG,CAAY,CAAC,GAAG,UAAU,IAAI,EAAA;UAC3C,IAAI,CAAC,kBAAkB,CAAC,CAAC,EAAE,IAAI,CAAC;QAClC,CAAC;QACD,KAAI,CAAC,UAAA,CAAA,MAAA,CAAW,GAAG,CAAgB,CAAC,GAAG,UAAU,IAAI,EAAA;UACnD,IAAI,CAAC,0BAA0B,CAAC,CAAC,EAAE,IAAI,CAAC;QAC1C,CAAC;QACD,KAAI,CAAC,cAAA,CAAA,MAAA,CAAe,GAAG,CAAoB,CAAC,GAAG,UAAU,IAAI,EAAA;UAC3D,IAAI,CAAC,wBAAwB,CAAC,CAAC,EAAE,IAAI,CAAC;QACxC,CAAC;QACD,KAAI,CAAC,kBAAA,CAAA,MAAA,CAAmB,GAAG,CAAwB,CAAC,GAAG,UAAU,IAAI,EAAA;UACnE,IAAI,CAAC,gCAAgC,CAAC,CAAC,EAAE,IAAI,CAAC;QAChD,CAAC;;MAlCH;;;;;;;;AAQG;MACH,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAA;gBAAlB,CAAC,CAAA;MA0BT;MAED;MACA,KAAI,CAAC,SAAS,CAAC,GAAG,UAAU,GAAG,EAAE,IAAI,EAAE,IAAI,EAAA;QACzC,OAAO,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC;MACpD,CAAC;MACD,KAAI,CAAC,SAAS,CAAC,GAAG,UAAU,GAAG,EAAE,IAAI,EAAE,IAAI,EAAA;QACzC,OAAO,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,CAAQ;MAC3D,CAAC;MACD,KAAI,CAAC,QAAQ,CAAC,GAAG,UAAU,GAAG,EAAE,IAAI,EAAA;QAClC,OAAO,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,GAAG,CAAC;MAC7C,CAAC;MACD,KAAI,CAAC,IAAI,CAAC,GAAG,UAAU,GAAG,EAAE,IAAI,EAAA;QAC9B,OAAO,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,GAAG,CAAC;MACzC,CAAC;MACD,KAAI,CAAC,MAAM,CAAC,GAAG,UAAU,GAAG,EAAE,IAAI,EAAA;QAChC,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,IAAI,CAAC;MACpC,CAAC;MACD,KAAI,CAAC,YAAY,CAAC,GAAG,UAAU,GAAG,EAAE,IAAI,EAAA;QACtC,IAAI,CAAC,wBAAwB,CAAC,GAAG,EAAE,IAAI,CAAC;MAC1C,CAAC;MAED,KAAI,CAAC,MAAM,GAAG,KAAI,CAAC,aAAa;MAChC,KAAI,CAAC,SAAS,GAAG,KAAI,CAAC,gBAAgB;MACtC,KAAI,CAAC,EAAE,GAAG,KAAI,CAAC,SAAS;IAC1B,CAAC,CAAC;EACJ,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,gBAAgB,GAAhB,YAAA;IAAA,IAAA,KAAA,GAAA,IAAA;IACE,IAAI,CAAC,eAAe,GAAG,KAAK;IAC5B;IACA;IACA;IACA;IACA,IAAI,CAAC,UAAU,CAAC,4BAA4B,EAAE,YAAA;MAC5C,IAAM,IAAI,GAAQ,KAAI;MAEtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;QAC3B,IAAM,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE;QAC1B,OAAO,IAAI,CAAC,SAAA,CAAA,MAAA,CAAU,GAAG,CAAE,CAAC;QAC5B,OAAO,IAAI,CAAC,SAAA,CAAA,MAAA,CAAU,GAAG,CAAE,CAAC;QAC5B,OAAO,IAAI,CAAC,QAAA,CAAA,MAAA,CAAS,GAAG,CAAE,CAAC;QAC3B,OAAO,IAAI,CAAC,IAAA,CAAA,MAAA,CAAK,GAAG,CAAE,CAAC;QACvB,OAAO,IAAI,CAAC,MAAA,CAAA,MAAA,CAAO,GAAG,CAAE,CAAC;QACzB,OAAO,IAAI,CAAC,UAAA,CAAA,MAAA,CAAW,GAAG,CAAE,CAAC;QAC7B,OAAO,IAAI,CAAC,cAAA,CAAA,MAAA,CAAe,GAAG,CAAE,CAAC;QACjC,OAAO,IAAI,CAAC,kBAAA,CAAA,MAAA,CAAmB,GAAG,CAAE,CAAC;MACtC;MAED,OAAO,IAAI,CAAC,SAAS,CAAC;MACtB,OAAO,IAAI,CAAC,SAAS,CAAC;MACtB,OAAO,IAAI,CAAC,QAAQ,CAAC;MACrB,OAAO,IAAI,CAAC,IAAI,CAAC;MACjB,OAAO,IAAI,CAAC,MAAM,CAAC;MACnB,OAAO,IAAI,CAAC,YAAY,CAAC;MAEzB,OAAO,IAAI,CAAC,MAAM;MAClB,OAAO,IAAI,CAAC,SAAS;MACrB,OAAO,IAAI,CAAC,EAAE;IAChB,CAAC,CAAC;EACJ,CAAC;EAED;EACA;EACA;EACA,YAAA,CAAA,SAAA,CAAA,aAAa,GAAb,UAAsC,IAAa,EAAA;IACjD;EACF,CAAC;EAED;EACA,YAAA,CAAA,SAAA,CAAA,gBAAgB,GAAhB,UACE,WAAkC,EAClC,IAAY,EAAA;IAEZ,OAAO,YAAA;MAAM,OAAA,IAAI;IAAJ,CAAI;EACnB,CAAC;EAED;EACA;EACA,YAAA,CAAA,SAAA,CAAA,SAAS,GAAT,UAAU,OAAe,EAAA;IACvB;IACA;IACA,OAAO,QAAA,CAAA,WAAW;EACpB,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,kBAAkB,GAAlB,UAAmB,IAAY,EAAE,GAAa,EAAA;IAC5C,IAAI;MACF,IAAM,eAAe,GAAG,IAAI,MAAA,CAAA,IAAI,CAAC;QAAE,UAAU,EAAE,EAAE;QAAE,IAAI,EAAE;MAAI,CAAE,CAAC;MAChE,eAAe,CAAC,IAAI,GAAG,IAAI;MAC3B,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,eAAe,CAAC;MAC7C,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC;MACd,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE;MAC7B,OAAO,eAAe;KACvB,CAAC,OAAO,aAAa,EAAE;MACtB,IAAI,aAAa,CAAC,oBAAoB,KAAK,IAAI,EAAE;QAC/C,IAAI;UACF,aAAa,CAAC,OAAO,GACnB,aAAa,CAAC,OAAO,GACrB,wFAAwF,GACxF,mEAAmE;SACtE,CAAC,OAAO,eAAe,EAAE;UACxB;UACA,MAAM,aAAa;QACpB;MACF;MACD,MAAM,aAAa;IACpB;EACH,CAAC;EAED;EACA,YAAA,CAAA,SAAA,CAAA,oBAAoB,GAApB,UAEE,iBAA0D,EAC1D,UAAkB,EAAA;IAElB,OAAO,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,MAAA,CAAA,MAAM,EAAE,iBAAiB,EAAE,UAAU,CAAC;EACrE,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,wBAAwB,GAAxB,UAEE,UAAkB,EAClB,iBAAiE,EAAA;IAEjE,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,MAAA,CAAA,mBAAmB,EAAE,iBAAiB,EAAE,UAAU,CAAC;EAC3E,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,gCAAgC,GAAhC,UAEE,UAAkB,EAClB,OAAqC,EAAA;IAErC,UAAU,CAAC,IAAI,CACb,IAAI,EACJ,MAAA,CAAA,gCAAgC,EAChC,OAAO,EACP,UAAU,EACV,gBAAgB,CACjB;EACH,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,kBAAkB,GAAlB,UAEE,UAAkB,EAClB,iBAA0D,EAAA;IAE1D,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,MAAA,CAAA,UAAU,EAAE,iBAAiB,EAAE,UAAU,CAAC;EAClE,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,0BAA0B,GAA1B,UAEE,UAAkB,EAClB,OAA+B,EAAA;IAE/B,UAAU,CAAC,IAAI,CACb,IAAI,EACJ,MAAA,CAAA,uBAAuB,EACvB,OAAO,EACP,UAAU,EACV,gBAAgB,CACjB;EACH,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,gBAAgB,GAAhB,UAEE,UAAiD,EACjD,UAAkB,EAAA;IAElB,OAAO,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,UAAU,CAAC;EACxD,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,qBAAqB,GAArB,UAEE,UAAyC,EACzC,UAAkB,EAClB,OAAiC,EAAA;IAEjC,sBAAsB,CAAC,UAAU,CAAC;IAClC,IAAI,CAAC,UAAU,IAAI,CAAA,CAAA,EAAA,KAAA,CAAA,OAAG,EAAC,UAAU,EAAE,UAAU,CAAC,KAAK,KAAK,EAAE;MACxD,IAAM,KAAK,GAAQ,IAAI,KAAK,CAC1B,UAAA,CAAA,MAAA,CAAW,YAAY,CAAC,UAAU,CAAC,EAAA,uBAAA,CAAuB,GACxD,iDAAA,CAAA,MAAA,CAAkD,IAAI,CAAC,SAAS,CAC9D,UAAU,CACX,EAAA,GAAA,CAAG,GACJ,6BAAA,CAAA,MAAA,CACS,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAE,CAAC,IAAI,EAAA,GAAA,CACtC,CACN;MACD,KAAK,CAAC,oBAAoB,GAAG,IAAI;MACjC,MAAM,KAAK;IACZ;IAED,IAAM,QAAQ,GAAQ,CAAA,CAAA,EAAA,MAAA,CAAA,OAAI,EAAC,IAAI,CAAC,kBAAkB,CAAC;IACnD,IAAM,QAAQ,GAAG,UAAU,CAAC,QAAQ;IACpC,IAAM,eAAe,GAAG,IAAI,MAAA,CAAA,WAAW,CAAC;MACtC,GAAG,EAAE,UAAU;MACf,eAAe,EAAE,QAAQ;MACzB,KAAK,EAAE,OAAO,KAAA,IAAA,IAAP,OAAO,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAP,OAAO,CAAE,KAAK;MACrB;MACA,cAAc,EAAE;KACjB,CAAC;IACF,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,eAAe,CAAC;IAEzC,OAAO,IAAI,CAAC,SAAS,GAAG,uBAAuB,GAAQ,qBAAqB;EAC9E,CAAC;EAED,YAAA,CAAA,SAAA,CAAA,qBAAqB,GAArB,UAEE,OAAkB,EAClB,UAAkB,EAClB,OAA2B,EAAA;IAE3B,sBAAsB,CAAC,UAAU,CAAC;IAClC,IAAI,CAAC,CAAA,CAAA,EAAA,QAAA,CAAA,mBAAmB,EAAC,OAAO,CAAC,EAAE;MACjC,IAAM,KAAK,GAAQ,IAAI,KAAK,CAC1B,UAAA,CAAA,MAAA,CAAW,YAAY,CAAC,UAAU,CAAC,EAAA,uBAAA,CAAuB,GACxD,6CAAA,CAAA,MAAA,CAA8C,IAAI,CAAC,SAAS,CAC1D,OAAO,CACR,EAAA,GAAA,CAAG,GACJ,6BAAA,CAAA,MAAA,CACS,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAE,CAAC,IAAI,EAAA,GAAA,CACtC,CACN;MACD,KAAK,CAAC,oBAAoB,GAAG,IAAI;MACjC,MAAM,KAAK;IACZ;IACD,IAAM,QAAQ,GAAQ,CAAA,CAAA,EAAA,MAAA,CAAA,OAAI,EAAC,IAAI,CAAC,kBAAkB,CAAC;IACnD,IAAM,eAAe,GAAG,IAAI,MAAA,CAAA,QAAQ,CAAC;MACnC,GAAG,EAAE,UAAU;MACf,YAAY,EAAE,OAAO;MACrB,KAAK,EAAE,OAAO,KAAA,IAAA,IAAP,OAAO,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAP,OAAO,CAAE;KACjB,CAAC;IACF,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,eAAe,CAAC;IAEzC,OAAO,qBAAqB;EAC9B,CAAC;EACH,OAAA,YAAC;AAAD,CAAC,EAAA;AA3RY,OAAA,CAAA,YAAA,GAAA,YAAA;AA6Rb,SAAS,UAAU,CACjB,eAAoB,EACpB,WAAgB,EAChB,UAAkB,EAClB,SAA0B,EAAA;EAA1B,IAAA,SAAA,KAAA,KAAA,CAAA,EAAA;IAAA,SAAA,GAAA,KAA0B;EAAA;EAE1B,sBAAsB,CAAC,UAAU,CAAC;EAClC,IAAM,QAAQ,GAAQ,CAAA,CAAA,EAAA,MAAA,CAAA,OAAI,EAAC,IAAI,CAAC,kBAAkB,CAAC;EACnD,IAAM,aAAa,GAAG,CAAA,CAAA,EAAA,YAAA,CAAA,OAAU,EAAC,WAAW,CAAC,GAAG,WAAW,GAAG,WAAW,CAAC,GAAG;EAE7E,IAAM,OAAO,GAAG,IAAI,eAAe,CAAC;IAAE,UAAU,EAAE,EAAE;IAAE,GAAG,EAAE;EAAU,CAAE,CAAC;EACxE,IAAI,SAAS,EAAE;IACb,OAAO,CAAC,SAAS,GAAG,WAAW,CAAC,GAAG;EACpC;EACD,IAAI,CAAA,CAAA,EAAA,KAAA,CAAA,OAAG,EAAC,WAAW,EAAE,eAAe,CAAC,EAAE;IACrC,OAAO,CAAC,YAAY,GAAG,WAAW,CAAC,aAAa;EACjD;EAED,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC;EACrC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC;EACxB,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC;EACjC,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE;EAE7B,OAAO,qBAAqB;AAC9B;AAEA,SAAS,YAAY,CAAC,WAAgB,EAAE,UAAkB,EAAA;EAA1D,IAAA,KAAA,GAAA,IAAA;EACE,sBAAsB,CAAC,UAAU,CAAC;EAClC,IAAM,QAAQ,GAAQ,CAAA,CAAA,EAAA,MAAA,CAAA,OAAI,EAAC,IAAI,CAAC,kBAAkB,CAAC;EACnD;EACA,IAAM,UAAU,GAAG,CAAA,CAAA,EAAA,SAAA,CAAA,OAAO,EAAC,WAAW,CAAC,KAAK,KAAK;EACjD,IAAM,IAAI,GACR,UAAU,KAAK,KAAK,GAAG,WAAW,GAAG,WAAW,CAAC,GAAG;EAEtD,IAAM,SAAS,GAAG,IAAI,MAAA,CAAA,WAAW,CAAC;IAChC,UAAU,EAAE,EAAE;IACd,GAAG,EAAE,UAAU;IACf,iBAAiB,EAAE,UAAU,IAAI,WAAW,CAAC,kBAAkB,KAAK;GACrE,CAAC;EACF,IAAI,CAAA,CAAA,EAAA,KAAA,CAAA,OAAG,EAAC,WAAW,EAAE,eAAe,CAAC,EAAE;IACrC,SAAS,CAAC,YAAY,GAAG,WAAW,CAAC,aAAa;EACnD;EAED,IAAM,aAAa,GAAG,CAAA,CAAA,EAAA,MAAA,CAAA,OAAI,EAAC,IAAI,EAAE,UAAC,OAAY,EAAA;IAAK,OAAA,CAAA,CAAA,EAAA,YAAA,CAAA,OAAU,EAAC,OAAO,CAAC,IAAI,CAAC;EAAxB,CAAwB,CAAC;EAC5E,SAAS,CAAC,aAAa,GAAG,aAAa;EAEvC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC;EAEnC,CAAA,CAAA,EAAA,SAAA,CAAA,OAAO,EAAC,IAAI,EAAE,UAAC,OAAO,EAAA;IACpB,IAAM,WAAW,GAAG,IAAI,MAAA,CAAA,WAAW,CAAC;MAAE,UAAU,EAAE;IAAE,CAAE,CAAC;IACvD,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,CAAC;IACtC,IAAI,CAAA,CAAA,EAAA,KAAA,CAAA,OAAG,EAAC,OAAO,EAAE,oBAAoB,CAAC,EAAE;MACtC,WAAW,CAAC,iBAAiB,GAAG,OAAO,CAAC,kBAA6B,CAAA,CAAC;IACvE;IACD;IAAA,KACK,IAAI,CAAA,CAAA,EAAA,KAAA,CAAA,OAAG,EAAC,OAAO,EAAE,MAAM,CAAC,EAAE;MAC7B,WAAW,CAAC,iBAAiB,GAAG,IAAI;IACrC;IACD,KAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,WAAW,CAAC;IACzC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,KAAI,CAAC;IACtB,KAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE;EAC/B,CAAC,CAAC;EACF,OAAO,qBAAqB;AAC9B;AAEA,SAAS,YAAY,CAAC,GAAW,EAAA;EAC/B,OAAO,GAAG,KAAK,CAAC,GAAG,EAAE,GAAG,EAAA,CAAA,MAAA,CAAG,GAAG,CAAE;AAClC;AAEA,SAAS,sBAAsB,CAAC,GAAW,EAAA;EACzC,IAAI,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,cAAc,EAAE;IACnC,IAAM,KAAK,GAAQ,IAAI,KAAK;IAC1B;IACA,iCAAA,CAAA,MAAA,CAAkC,GAAG,EAAA,OAAA,CAAO,GAC1C,uDAAA,CAAA,MAAA,CACE,cAAc,GAAG,CAAC,CAClB,CACL;IACD,KAAK,CAAC,oBAAoB,GAAG,IAAI;IACjC,MAAM,KAAK;EACZ;AACH","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GastRecorder = void 0;\nvar last_1 = __importDefault(require(\"lodash/last\"));\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar some_1 = __importDefault(require(\"lodash/some\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar isFunction_1 = __importDefault(require(\"lodash/isFunction\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar gast_1 = require(\"@chevrotain/gast\");\nvar lexer_public_1 = require(\"../../../scan/lexer_public\");\nvar tokens_1 = require(\"../../../scan/tokens\");\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar parser_1 = require(\"../parser\");\nvar keys_1 = require(\"../../grammar/keys\");\nvar RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = (0, tokens_public_1.createToken)({ name: \"RECORDING_PHASE_TOKEN\", pattern: lexer_public_1.Lexer.NA });\n(0, tokens_1.augmentTokenTypes)([RFT]);\nvar RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n    children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nvar GastRecorder = /** @class */ (function () {\n    function GastRecorder() {\n    }\n    GastRecorder.prototype.initGastRecorder = function (config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    };\n    GastRecorder.prototype.enableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", function () {\n            var _loop_1 = function (i) {\n                var idx = i > 0 ? i : \"\";\n                _this[\"CONSUME\".concat(idx)] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                _this[\"SUBRULE\".concat(idx)] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                _this[\"OPTION\".concat(idx)] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                _this[\"OR\".concat(idx)] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                _this[\"MANY\".concat(idx)] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                _this[\"MANY_SEP\".concat(idx)] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE\".concat(idx)] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE_SEP\".concat(idx)] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            };\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (var i = 0; i < 10; i++) {\n                _loop_1(i);\n            }\n            // DSL methods with the idx(suffix) as an argument\n            _this[\"consume\"] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"subrule\"] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"option\"] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            _this[\"or\"] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            _this[\"many\"] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            _this[\"atLeastOne\"] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            _this.ACTION = _this.ACTION_RECORD;\n            _this.BACKTRACK = _this.BACKTRACK_RECORD;\n            _this.LA = _this.LA_RECORD;\n        });\n    };\n    GastRecorder.prototype.disableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", function () {\n            var that = _this;\n            for (var i = 0; i < 10; i++) {\n                var idx = i > 0 ? i : \"\";\n                delete that[\"CONSUME\".concat(idx)];\n                delete that[\"SUBRULE\".concat(idx)];\n                delete that[\"OPTION\".concat(idx)];\n                delete that[\"OR\".concat(idx)];\n                delete that[\"MANY\".concat(idx)];\n                delete that[\"MANY_SEP\".concat(idx)];\n                delete that[\"AT_LEAST_ONE\".concat(idx)];\n                delete that[\"AT_LEAST_ONE_SEP\".concat(idx)];\n            }\n            delete that[\"consume\"];\n            delete that[\"subrule\"];\n            delete that[\"option\"];\n            delete that[\"or\"];\n            delete that[\"many\"];\n            delete that[\"atLeastOne\"];\n            delete that.ACTION;\n            delete that.BACKTRACK;\n            delete that.LA;\n        });\n    };\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    // @ts-expect-error -- noop place holder\n    GastRecorder.prototype.ACTION_RECORD = function (impl) {\n        // NO-OP during recording\n    };\n    // Executing backtracking logic will break our recording logic assumptions\n    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n        return function () { return true; };\n    };\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    GastRecorder.prototype.LA_RECORD = function (howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return parser_1.END_OF_FILE;\n    };\n    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n        try {\n            var newTopLevelRule = new gast_1.Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    };\n    // Implementation of parsing DSL\n    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n        return recordProd.call(this, gast_1.Option, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, gast_1.RepetitionMandatory, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, gast_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, gast_1.Repetition, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, gast_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    };\n    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || (0, has_1.default)(ruleToCall, \"ruleName\") === false) {\n            var error = new Error(\"<SUBRULE\".concat(getIdxSuffix(occurrence), \"> argument is invalid\") +\n                \" expecting a Parser method reference but got: <\".concat(JSON.stringify(ruleToCall), \">\") +\n                \"\\n inside top level rule: <\".concat(this.recordingProdStack[0].name, \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = (0, last_1.default)(this.recordingProdStack);\n        var ruleName = ruleToCall.ruleName;\n        var newNoneTerminal = new gast_1.NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n    };\n    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {\n            var error = new Error(\"<CONSUME\".concat(getIdxSuffix(occurrence), \"> argument is invalid\") +\n                \" expecting a TokenType reference but got: <\".concat(JSON.stringify(tokType), \">\") +\n                \"\\n inside top level rule: <\".concat(this.recordingProdStack[0].name, \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = (0, last_1.default)(this.recordingProdStack);\n        var newNoneTerminal = new gast_1.Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    };\n    return GastRecorder;\n}());\nexports.GastRecorder = GastRecorder;\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n    if (handleSep === void 0) { handleSep = false; }\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = (0, last_1.default)(this.recordingProdStack);\n    var grammarAction = (0, isFunction_1.default)(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n    var newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if ((0, has_1.default)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    var _this = this;\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = (0, last_1.default)(this.recordingProdStack);\n    // Only an array of alternatives\n    var hasOptions = (0, isArray_1.default)(mainProdArg) === false;\n    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    var newOrProd = new gast_1.Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n    });\n    if ((0, has_1.default)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    var hasPredicates = (0, some_1.default)(alts, function (currAlt) { return (0, isFunction_1.default)(currAlt.GATE); });\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    (0, forEach_1.default)(alts, function (currAlt) {\n        var currAltFlat = new gast_1.Alternative({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if ((0, has_1.default)(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES; // assumes end user provides the correct config value/type\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if ((0, has_1.default)(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        _this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(_this);\n        _this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : \"\".concat(idx);\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        var error = new Error(\n        // The stack trace will contain all the needed details\n        \"Invalid DSL Method idx value: <\".concat(idx, \">\\n\\t\") +\n            \"Idx value must be a none negative value smaller than \".concat(MAX_METHOD_IDX + 1));\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map"]},"metadata":{},"sourceType":"script"}